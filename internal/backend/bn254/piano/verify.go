// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package piano

import (
	"crypto/sha256"
	"fmt"
	"math/big"
	"time"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/sunblaze-ucb/simpleMPI/mpi"

	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	bn254witness "github.com/consensys/gnark/internal/backend/bn254/witness"

	"github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark/logger"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/dkzg"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/kzg"
)

func Verify(proof *Proof, vk *VerifyingKey, publicWitness bn254witness.Witness) error {
	log := logger.Logger().With().Str("curve", "bn254").Str("backend", "piano").Logger()
	start := time.Now()

	// pick a hash function to derive the challenge (the same as in the prover)
	hFunc := sha256.New()

	// transcript to derive the challenge
	fs := fiatshamir.NewTranscript(hFunc, "gamma", "eta", "lambda", "alpha", "beta")

	// The first challenge is derived using the public data: the commitments to the permutation,
	// the coefficients of the circuit, and the public inputs.
	// derive gamma from the Comm(blinded cl), Comm(blinded cr), Comm(blinded co)
	if err := bindPublicData(&fs, "gamma", *vk, publicWitness); err != nil {
		return err
	}
	bgamma, err := fs.ComputeChallenge("gamma")
	if err != nil {
		return err
	}
	var gamma fr.Element
	gamma.SetBytes(bgamma)

	// derive eta from Comm(l), Comm(r), Comm(o)
	eta, err := deriveRandomness(&fs, "eta")
	if err != nil {
		return err
	}

	// derive lambda from Comm(l), Comm(r), Comm(o), Com(Z)
	lambda, err := deriveRandomness(&fs, "lambda", &proof.Z)
	lambda = fr.NewElement(0)
	if err != nil {
		return err
	}

	// derive alpha, the point of evaluation
	alpha, err := deriveRandomness(&fs, "alpha", &proof.Hx[0], &proof.Hx[1], &proof.Hx[2])
	if err != nil {
		return err
	}

	// evaluation of Z=Xⁿ⁻¹ at α
	var alphaPowerN, zalpha fr.Element
	var bExpo big.Int
	one := fr.One()
	bExpo.SetUint64(vk.Size)
	alphaPowerN.Exp(alpha, &bExpo)
	zalpha.Sub(&alphaPowerN, &one)

	// compute the folded commitment to H: Comm(h₁) + αᵐ⁺²*Comm(h₂) + α²⁽ᵐ⁺²⁾*Comm(h₃)
	nPlusTwo := big.NewInt(int64(vk.Size) + 2)
	var alphaNPlusTwo fr.Element
	alphaNPlusTwo.Exp(alpha, nPlusTwo)
	var alphaNPlusTwoBigInt big.Int
	alphaNPlusTwo.ToBigIntRegular(&alphaNPlusTwoBigInt)
	foldedHxDigest := proof.Hx[2]
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &alphaNPlusTwoBigInt)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[1])
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &alphaNPlusTwoBigInt)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[0])

	foldedPartialProof, foldedPartialDigest, err := dkzg.FoldProof(
		[]dkzg.Digest{
			proof.LRO[0],
			proof.LRO[1],
			proof.LRO[2],
			vk.Ql,
			vk.Qr,
			vk.Qm,
			vk.Qo,
			vk.Qk,
			vk.S[0],
			vk.S[1],
			vk.S[2],
			proof.Z,
			foldedHxDigest,
		},
		&proof.PartialBatchedProof,
		alpha,
		hFunc)

	if err != nil {
		return fmt.Errorf("failed to fold proof on X = alpha: %v", err)
	}
	// Batch verify
	var shiftedalpha fr.Element
	shiftedalpha.Mul(&alpha, &vk.Generator)
	err = dkzg.BatchVerifyMultiPoints(
		[]dkzg.Digest{
			foldedPartialDigest,
			proof.Z,
		},
		[]dkzg.OpeningProof{
			foldedPartialProof,
			proof.PartialZShiftedOpening,
		},
		[]fr.Element{
			alpha,
			shiftedalpha,
		},
		vk.KZGSRS,
	)
	if err != nil {
		return fmt.Errorf("failed to batch verify on X = alpha: %v", err)
	}

	// derive beta
	beta, err := deriveRandomness(&fs, "beta", &proof.Hy[0], &proof.Hy[1], &proof.Hy[2])
	if err != nil {
		return err
	}

	var l, r, o, ql, qr, qm, qo, qk, s1, s2, s3, z, zmu fr.Element
	unpack(proof.BatchedProof.ClaimedValues, &l, &r, &o, &ql, &qr, &qm, &qo, &qk, &s1, &s2, &s3, &z, &zmu)

	// The Linearized identities is:
	// lambda**2 * L1(alpha)*(Z(beta, alpha) - 1)
	// + lambda * ((L(beta, alpha)+eta*S1(beta, alpha)+gamma) * (R(beta, alpha)+eta*S2(beta, alpha)+gamma) * (O(beta, alpha)+eta*S3(beta, alpha)+gamma) * Z(beta, mu*alpha)
	//		 - (L(beta, alpha)+eta*id1(beta, alpha)+gamma) * (R(beta, alpha)+eta*id2(beta, alpha)+gamma) * (O(beta, alpha)+eta*id3(beta, alpha)+gamma)*Z(beta, alpha) )
	// + Ql(beta, alpha)*L(beta, alpha) + Qm(beta, alpha)*L(beta, alpha)R(beta, alpha) + Qr(beta, alpha)*R(beta, alpha) + Qo(beta, alpha)*O(beta, alpha) + Qk(beta, alpha)
	// - Zn(alpha)*Hx(Y,alpha) - Zm(beta)*FoldedHy(Y) = 0
	//
	// first part: individual constraints
	var firstPart fr.Element
	ql.Mul(&ql, &l)
	qr.Mul(&qr, &r)
	qm.Mul(&qm, &l).Mul(&qm, &r)
	qo.Mul(&qo, &o)
	firstPart.Add(&ql, &qr).Add(&firstPart, &qm).Add(&firstPart, &qo).Add(&firstPart, &qk)

	// second part:
	// ((L(beta, alpha)+eta*S1(beta, alpha)+gamma) * (R(beta, alpha)+eta*S2(beta, alpha)+gamma) * (O(beta, alpha)+eta*S3(beta, alpha)+gamma) * Z(beta, mu*alpha)
	s1.Mul(&s1, &eta).Add(&s1, &l).Add(&s1, &gamma)
	s2.Mul(&s2, &eta).Add(&s2, &r).Add(&s2, &gamma)
	s3.Mul(&s3, &eta).Add(&s3, &o).Add(&s3, &gamma)
	s1.Mul(&s1, &s2).Mul(&s1, &s3).Mul(&s1, &zmu)

	var ualpha, uualpha fr.Element
	ualpha.Mul(&alpha, &vk.CosetShift)
	uualpha.Mul(&alpha, &vk.CosetShift)

	var secondPart, t1, t2, t3 fr.Element
	t1.Mul(&eta, &alpha).Add(&t1, &l).Add(&t1, &gamma)
	t2.Mul(&eta, &ualpha).Add(&t2, &r).Add(&t2, &gamma)
	t3.Mul(&eta, &uualpha).Add(&t3, &o).Add(&t3, &gamma)
	secondPart.Mul(&t1, &t2).Mul(&secondPart, &t3)
	secondPart.Sub(&s1, &secondPart)

	// third part L1(alpha) * (Z(beta, alpha)-1)
	var thirdPart, den, frNbElmt fr.Element
	z.Sub(&z, &one)
	nbElmt := int64(vk.Size)
	thirdPart.Set(&alpha).
		Exp(thirdPart, big.NewInt(nbElmt)).
		Sub(&thirdPart, &one)
	frNbElmt.SetUint64(uint64(nbElmt))
	den.Sub(&alpha, &one).
		Inverse(&den)
	thirdPart.Mul(&thirdPart, &den).
		Mul(&thirdPart, &vk.SizeInv).
		Mul(&thirdPart, &z)

	var constTerm fr.Element
	constTerm.Mul(&thirdPart, &lambda).Add(&constTerm, &secondPart).Mul(&constTerm, &lambda).Add(&constTerm, &firstPart)

	var hxTerm, hyTerm fr.Element
	hxTerm.Exp(alpha, big.NewInt(int64(vk.Size)))
	hxTerm.Sub(&one, &hxTerm)
	hyTerm.Exp(beta, big.NewInt(int64(globalDomain[0].Cardinality)))
	hyTerm.Sub(&one, &hyTerm)

	// foldedHy = hy1 + (beta**M)hy2 + (beta**(2M))*hy3
	var bBetaPowerM, bSize big.Int
	bSize.SetUint64(globalDomain[0].Cardinality)
	var betaPowerM fr.Element
	betaPowerM.Exp(alpha, &bSize)
	betaPowerM.ToBigIntRegular(&bBetaPowerM)
	foldedHyDigest := proof.Hy[2]
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM)
	foldedHyDigest.Add(&foldedHxDigest, &proof.Hy[1])
	foldedHyDigest.ScalarMultiplication(&foldedHxDigest, &bBetaPowerM)
	foldedHyDigest.Add(&foldedHxDigest, &proof.Hy[0])

	points := []curve.G1Affine{
		vk.KZGSRS.G1[0],
		proof.PartialBatchedProof.ClaimedDigests[0],
		foldedHyDigest,
	}

	scalars := []fr.Element{
		constTerm,
		hxTerm,
		hyTerm,
	}

	var linearizedIdentitiesDigest curve.G1Affine
	if _, err := linearizedIdentitiesDigest.MultiExp(points, scalars, ecc.MultiExpConfig{ScalarsMont: true}); err != nil {
		return err
	}

	eval := proof.BatchedProof.ClaimedValues[len(proof.BatchedProof.ClaimedValues)-1]
	if (eval != fr.NewElement(0)) {
		return fmt.Errorf("evaluation of identities is %v, expected 0", eval)
	}

	// Fold the first proof
	if err := kzg.BatchVerifySinglePoint(
		append(proof.PartialBatchedProof.ClaimedDigests[1:],
			proof.PartialZShiftedOpening.ClaimedDigest,
			linearizedIdentitiesDigest,
		),
		&proof.BatchedProof,
		beta,
		hFunc,
		globalSRS,
	); err != nil {
		return err
	}

	log.Debug().Dur("took", time.Since(start)).Msg("verifier done")

	return err
}

// unpack unpacks evaluations from an array
func unpack(src []fr.Element, dst ...*fr.Element) {
	for i := range dst {
		*dst[i] = src[i]
	}
}

func bindPublicData(fs *fiatshamir.Transcript, challenge string, vk VerifyingKey, publicInputs []fr.Element) error {
	// permutation
	if err := fs.Bind(challenge, vk.S[0].Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.S[1].Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.S[2].Marshal()); err != nil {
		return err
	}

	// coefficients
	if err := fs.Bind(challenge, vk.Ql.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qr.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qm.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qo.Marshal()); err != nil {
		return err
	}
	if err := fs.Bind(challenge, vk.Qk.Marshal()); err != nil {
		return err
	}

	return nil
}

func deriveRandomness(fs *fiatshamir.Transcript, challenge string, points ...*curve.G1Affine) (fr.Element, error) {
	if mpi.SelfRank == 0{
		var buf [curve.SizeOfG1AffineUncompressed]byte
		var r fr.Element

		for _, p := range points {
			buf = p.RawBytes()
			if err := fs.Bind(challenge, buf[:]); err != nil {
				return r, err
			}
		}

		b, err := fs.ComputeChallenge(challenge)
		if err != nil {
			return r, err
		}
		r.SetBytes(b)
		sendBuf := r.Bytes()
		for i := 1; i < int(mpi.WorldSize); i++ {
			mpi.SendBytes(sendBuf[:], uint64(i))
		}
		return r, nil
	} else {
		var r fr.Element
		recvBuf, err := mpi.ReceiveBytes(fr.Bytes, 0)
		if err != nil {
			return r, err
		}
		r.SetBytes(recvBuf)
		return r, nil
	}
}
