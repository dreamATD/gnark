// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package piano

import (
	"crypto/sha256"
	"fmt"
	"math/big"
	"math/bits"
	"runtime"
	"sync"
	"time"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/dkzg"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/fft"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/kzg"
	"github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark/backend"
	"github.com/consensys/gnark/internal/backend/bn254/cs"
	"github.com/consensys/gnark/internal/utils"
	"github.com/consensys/gnark/logger"
	"github.com/sunblaze-ucb/simpleMPI/mpi"

	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	bn254witness "github.com/consensys/gnark/internal/backend/bn254/witness"
)

var (
	World *mpi.MPIWorld
)

// Proof denotes a Piano proof generated from M parties each with N rows.
type Proof struct {

	// Commitments to the solution vectors
	LROD [4]dkzg.Digest

	// Commitment to Z, the permutation polynomial
	Z dkzg.Digest

	// Commitments to Hx1, Hx2, Hx3 such that
	// Hx = Hx1 + (X**N) * Hx2 + (X**(2N)) * Hx3 + (X**(3N)) * Hx4 and
	// commitments to Hy1, Hy2, Hy3 such that
	// Hy = Hy1 + (Y**M) * Hy2 + (Y**(2M)) * Hy3 + (Y**(3M)) * Hy4
	Hx [4]dkzg.Digest
	Hy [4]kzg.Digest

	// Batch partially opening proof of
	// foldedHx(Y, X) = Hx1(Y, X) + (alpha**N)*Hx2(Y, X) + (alpha**(2N))*Hx3(Y, X) + (alpha**(3N))*Hx4(Y, X),
	// L(Y, X), R(Y, X), O(Y, X), D(Y, X), Ql(Y, X), Qr(Y, X), Qm(Y, X), Qo(Y, X), Qd(Y, X), Qnd(Y, X)
	// Qk(Y, X), S1(Y, X), S2(Y, X), S3(Y, X), S4(Y, X)
	// Z(Y, X) on X = alpha
	PartialBatchedProof dkzg.BatchOpeningProof

	// Opening partially proof of Z(Y, X) and D(Y, X) on X = mu*alpha
	PartialBatchedShiftedProof dkzg.BatchOpeningProof

	// Batch opening proof of L(Y, alpha), R(Y, alpha), O(Y, alpha), D(Y, alpha), D(Y, mu*alpha)
	// Ql(Y, alpha), Qr(Y, alpha), Qm(Y, alpha), Qo(Y, alpha), Qd(Y, alpha), Qnd(Y, alpha), Qk(Y, alpha),
	// S1(Y, alpha), S2(Y, alpha), S3(Y, alpha), S4(Y, alpha), Z(Y, alpha), z(Y, mu*alpha),
	BatchedProof kzg.BatchOpeningProof
}

// Prove from the public data
func Prove(spr *cs.SparseR1CS, pk *ProvingKey, fullWitness bn254witness.Witness, opt backend.ProverConfig) (*Proof, error) {
	fmt.Println("Prover started")
	log := logger.Logger().With().Str("curve", spr.CurveID().String()).Int("nbConstraints", len(spr.Constraints)).Str("backend", "piano").Logger()
	start := time.Now()
	// pick a hash function that will be used to derive the challenges
	hFunc := sha256.New()

	// create a transcript manager to apply Fiat Shamir
	fs := fiatshamir.NewTranscript(hFunc, "gamma", "eta", "lambda", "alpha", "beta")

	// result
	proof := &Proof{}

	// The first challenge is derived using the public data: the commitments to the permutation,
	// the coefficients of the circuit, and the public inputs.
	// derive gamma from the Comm(blinded cL), Comm(blinded cR), Comm(blinded cO)
	if err := bindPublicData(&fs, "gamma", *pk.Vk, fullWitness[:spr.NbPublicVariables]); err != nil {
		return nil, err
	}

	// query L, R, O, D in Lagrange basis, not blinded
	lSmallX, rSmallX, oSmallX, dSmallX := readLRODSmallDomainX(pk)

	// save lL, lR, lO, lD, and make a copy of them in
	// canonical basis note that we allocate more capacity to reuse for blinded
	// polynomials
	lCanonicalX, rCanonicalX, oCanonicalX, dCanonicalX, err := computeLRODCanonicalX(
		lSmallX,
		rSmallX,
		oSmallX,
		dSmallX,
		&pk.Domain[0],
	)
	if err != nil {
		return nil, err
	}

	// compute kzg commitments of bcL, bcR and bcO
	if err := commitToLROD(lCanonicalX, rCanonicalX, oCanonicalX, dCanonicalX, proof, pk.Vk.KZGSRS); err != nil {
		return nil, err
	}

	gamma, err := deriveRandomness(&fs, "gamma", &proof.LROD[0], &proof.LROD[1], &proof.LROD[2], &proof.LROD[3])

	if err != nil {
		return nil, err
	}

	// Fiat Shamir this
	eta, err := deriveRandomness(&fs, "eta")
	if err != nil {
		return nil, err
	}

	// compute Z, the permutation accumulator polynomial, in canonical basis
	// lL, lR, lO, lD are NOT blinded
	zCanonicalX, err := computeZCanonicalX(
		lSmallX,
		rSmallX,
		oSmallX,
		dSmallX,
		pk, eta, gamma,
	)
	if err != nil {
		return nil, err
	}

	// commit to the blinded version of z
	// note that we explicitly double the number of tasks for the multi exp
	// in dkzg.Commit
	// this may add additional arithmetic operations, but with smaller tasks
	// we ensure that this commitment is well parallelized, without having a
	// "unbalanced task" making the rest of the code wait too long
	if proof.Z, err = dkzg.Commit(zCanonicalX, pk.Vk.KZGSRS, runtime.NumCPU()*2); err != nil {
		return nil, err
	}

	// derive lambda from the Comm(L), Comm(R), Comm(O), Com(Z)
	lambda, err := deriveRandomness(&fs, "lambda", &proof.Z)
	if err != nil {
		return nil, err
	}

	// evaluate bcL, bcR, bcO and bcZ on the coset of the big domain
	var (
		lBigXBitReversed []fr.Element
		rBigXBitReversed []fr.Element
		oBigXBitReversed []fr.Element
		dBigXBitReversed []fr.Element
		zBigXBitReversed []fr.Element
	)
	chEvalBL := make(chan struct{}, 1)
	chEvalBR := make(chan struct{}, 1)
	chEvalBO := make(chan struct{}, 1)
	chEvalBD := make(chan struct{}, 1)
	go func() {
		lBigXBitReversed = evaluateBigBitReversed(lCanonicalX, &pk.Domain[1])
		close(chEvalBL)
	}()
	go func() {
		rBigXBitReversed = evaluateBigBitReversed(rCanonicalX, &pk.Domain[1])
		close(chEvalBR)
	}()
	go func() {
		oBigXBitReversed = evaluateBigBitReversed(oCanonicalX, &pk.Domain[1])
		close(chEvalBO)
	}()
	go func() {
		dBigXBitReversed = evaluateBigBitReversed(dCanonicalX, &pk.Domain[1])
		close(chEvalBD)
	}()

	var gateConstraintBigXBitReversed, permConstraintBigXBitReversed []fr.Element
	chGateConstraint := make(chan struct{}, 1)
	go func() {
		// compute Qk in canonical basis, completed with the public inputs
		qkCompletedCanonical := make([]fr.Element, pk.Domain[0].Cardinality)
		copy(qkCompletedCanonical, pk.CQk)

		// compute the evaluation of ql(X)l(X) + qr(X)r(X) + qm(X)l(X)r(X)
		// + qo(X)o(X) + qd(X)d(X) + qnd(X)d(mu*X) + qk(X) on the big domain coset with the blinded version
		// of l(X), r(X), o(X), d(X) and the completed version of canonical qk(X)
		<-chEvalBL
		<-chEvalBR
		<-chEvalBO
		<-chEvalBD
		gateConstraintBigXBitReversed = evaluateGateConstraintBigXBitReversed(
			pk,
			lBigXBitReversed,
			rBigXBitReversed,
			oBigXBitReversed,
			dBigXBitReversed,
			qkCompletedCanonical,
		)
		close(chGateConstraint)
	}()

	chPermConstraint := make(chan error, 1)
	go func() {
		zBigXBitReversed = evaluateBigBitReversed(zCanonicalX, &pk.Domain[1])
		// compute z(muX)*g1(X)*g2(X)*g3(X)*g4(X) - z(X)*f1(X)*f2(X)*f3(X)*f4(X) on the
		// coset of the big domain with the evaluations of the blinded
		// versions of l(X), r(X), o(X), d(X) and z(X).
		<-chEvalBL
		<-chEvalBR
		<-chEvalBO
		<-chEvalBD
		permConstraintBigXBitReversed = evaluatePermConstraintBigXBitReversed(
			pk,
			lBigXBitReversed,
			rBigXBitReversed,
			oBigXBitReversed,
			dBigXBitReversed,
			zBigXBitReversed,
			eta,
			gamma,
		)
		chPermConstraint <- nil
		close(chPermConstraint)
	}()

	if err := <-chPermConstraint; err != nil {
		return nil, err
	}

	<-chGateConstraint

	// compute Hx in canonical form
	hx1, hx2, hx3, hx4 := computeQuotientCanonicalX(pk, gateConstraintBigXBitReversed, permConstraintBigXBitReversed, zBigXBitReversed, lambda)

	// compute kzg commitments of Hx1, Hx2, Hx3, Hx4
	if err := commitToQuotientX(hx1, hx2, hx3, hx4, proof, pk.Vk.KZGSRS); err != nil {
		return nil, err
	}

	// derive alpha
	alpha, err := deriveRandomness(&fs, "alpha", &proof.Hx[0], &proof.Hx[1], &proof.Hx[2], &proof.Hx[3])
	if err != nil {
		return nil, err
	}

	// open D and Z at mu*alpha
	var alphaShifted fr.Element
	alphaShifted.Mul(&alpha, &pk.Vk.Generator)
	var evalsXOnShiftedAlpha [][]fr.Element
	proof.PartialBatchedShiftedProof, evalsXOnShiftedAlpha, err = dkzg.BatchOpenSinglePoint(
		[][]fr.Element{
			dCanonicalX,
			zCanonicalX,
		},
		[]dkzg.Digest{
			proof.LROD[3],
			proof.Z,
		},
		alphaShifted,
		hFunc,
		pk.Vk.KZGSRS,
	)
	if err != nil {
		return nil, err
	}

	// foldedHDigest = Comm(Hx1) + (alpha**(N))*Comm(Hx2) + (alpha**(2(N)))*Comm(Hx3) + (alpha**(3(N)))*Comm(Hx4)
	var bAlphaPowerN, bSize big.Int
	bSize.SetUint64(pk.Domain[0].Cardinality)
	var alphaPowerN fr.Element
	alphaPowerN.Exp(alpha, &bSize)
	alphaPowerN.ToBigIntRegular(&bAlphaPowerN)
	foldedHxDigest := proof.Hx[3]
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerN) // (alpha**N)*Comm(Hx4)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[2])                   // (alpha**N)*Comm(Hx4) + Comm(Hx3)
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerN) // (alpha**(2N))*Comm(Hx4) + (alpha**N)*Comm(Hx3)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[1])                   // (alpha**(2N))*Comm(Hx4) + (alpha**N)*Comm(Hx3) + Comm(Hx2)
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerN) // (alpha**(3N))*Comm(Hx4) + (alpha**(2N))*Comm(Hx3) + (alpha**N)*Comm(Hx2)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[0])                   // (alpha**(3N))*Comm(Hx4) + (alpha**(2N))*Comm(Hx3) + (alpha**N)*Comm(Hx2) + Comm(Hx1)

	// foldedHx = Hx1 + (alpha**N)*Hx2 + (alpha**(2N))*Hx3 + (alpha**(3N))*Hx4
	foldedHx := hx4
	utils.Parallelize(len(foldedHx), func(start, end int) {
		for i := start; i < end; i++ {
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerN) // (alpha**N)*Hx4
			foldedHx[i].Add(&foldedHx[i], &hx3[i])      // (alpha**N)*Hx4 + Hx3
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerN) // (alpha**(2N))*Hx4 + (alpha**N)*Hx3
			foldedHx[i].Add(&foldedHx[i], &hx2[i])      // (alpha**(2N))*Hx4 + (alpha**N)*Hx3 + Hx2
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerN) // (alpha**(3N))*Hx4 + (alpha**(2N))*Hx3 + (alpha**N)*Hx2
			foldedHx[i].Add(&foldedHx[i], &hx1[i])      // (alpha**(3N))*Hx4 + (alpha**(2N))*Hx3 + (alpha**N)*Hx2 + Hx1
		}
	})

	dkzgOpeningPolys := [][]fr.Element{
		foldedHx,
		lCanonicalX,
		rCanonicalX,
		oCanonicalX,
		dCanonicalX,
		pk.Ql,
		pk.Qr,
		pk.Qm,
		pk.Qo,
		pk.Qd,
		pk.Qnd,
		pk.CQk,
		pk.S1Canonical,
		pk.S2Canonical,
		pk.S3Canonical,
		pk.S4Canonical,
		zCanonicalX,
	}
	dkzgDigests := []dkzg.Digest{
		foldedHxDigest,
		proof.LROD[0],
		proof.LROD[1],
		proof.LROD[2],
		proof.LROD[3],
		pk.Vk.Ql,
		pk.Vk.Qr,
		pk.Vk.Qm,
		pk.Vk.Qo,
		pk.Vk.Qd,
		pk.Vk.Qnd,
		pk.Vk.Qk,
		pk.Vk.S[0],
		pk.Vk.S[1],
		pk.Vk.S[2],
		pk.Vk.S[3],
		proof.Z,
	}

	// Batch open the first list of polynomials
	var evalsXOnAlpha [][]fr.Element
	proof.PartialBatchedProof, evalsXOnAlpha, err = dkzg.BatchOpenSinglePoint(
		dkzgOpeningPolys,
		dkzgDigests,
		alpha,
		hFunc,
		pk.Vk.KZGSRS,
	)

	if err != nil {
		return nil, err
	}

	if mpi.SelfRank != 0 {
		log.Debug().Dur("took", time.Since(start)).Msg("prover done")
		if err != nil {
			return nil, err
		}

		return proof, nil
	}

	zShiftedAlpha := evalsXOnShiftedAlpha[0]
	dShiftedAlpha := evalsXOnShiftedAlpha[1]

	// DBG check whether constraints are satisfied
	if err := checkConstraintX(
		pk,
		evalsXOnAlpha,
		evalsXOnShiftedAlpha,
		gamma,
		eta,
		lambda,
		alpha,
	); err != nil {
		return nil, err
	}

	gateConstraintSetSmallY := evalsXOnAlpha[1:12]
	gateConstraintSetSmallY = append(gateConstraintSetSmallY, dShiftedAlpha)

	// evaluate polynomials used in the gate constraint on the coset of the big
	// domain in terms of Y
	gateConstraintSetCanonicalY, gateConstraintSetBigYBitReversed := computeCanonicalAndBigFromSmallY(gateConstraintSetSmallY,
		globalDomain[0],
		globalDomain[1],
	)

	var gateConstraintBigYBitReversed []fr.Element
	chGateConstraint = make(chan struct{}, 1)
	go func() {
		gateConstraintBigYBitReversed = evaluateGateConstraintBigYBitReversed(
			gateConstraintSetBigYBitReversed[0],  // L(Y, alpha)
			gateConstraintSetBigYBitReversed[1],  // R(Y, alpha)
			gateConstraintSetBigYBitReversed[2],  // O(Y, alpha)
			gateConstraintSetBigYBitReversed[3],  // D(Y, alpha)
			gateConstraintSetBigYBitReversed[11], // D(Y, mu*alpha)
			gateConstraintSetBigYBitReversed[4],  // Ql(Y, alpha)
			gateConstraintSetBigYBitReversed[5],  // Qr(Y, alpha)
			gateConstraintSetBigYBitReversed[6],  // Qm(Y, alpha)
			gateConstraintSetBigYBitReversed[7],  // Qo(Y, alpha)
			gateConstraintSetBigYBitReversed[8],  // Qd(Y, alpha)
			gateConstraintSetBigYBitReversed[9],  // Qnd(Y, alpha)
			gateConstraintSetBigYBitReversed[10], // Qk(Y, alpha)
		)
		close(chGateConstraint)
	}()

	var permConstraintSetSmallY [][]fr.Element
	permConstraintSetSmallY = append(permConstraintSetSmallY, evalsXOnAlpha[12:]...)
	permConstraintSetSmallY = append(permConstraintSetSmallY, zShiftedAlpha)

	// evaluate polynomials used in the permutation constraint on the coset of
	// the big domain in terms of Y
	permConstraintSetCanonicalY, permConstraintSetBigYBitReversed := computeCanonicalAndBigFromSmallY(permConstraintSetSmallY,
		globalDomain[0],
		globalDomain[1],
	)

	var permConstraintBigYBitReversed []fr.Element
	chPermConstraint = make(chan error, 1)
	go func() {
		// compute Zmu*G1*G2*G3 - Z*F1*F2*F3 on the coset of the big domain in
		// terms of Y
		permConstraintBigYBitReversed = evaluatePermConstraintBigYBitReversed(
			pk,
			gateConstraintSetBigYBitReversed[0], // L(Y, alpha)
			gateConstraintSetBigYBitReversed[1], // R(Y, alpha)
			gateConstraintSetBigYBitReversed[2], // O(Y, alpha)
			gateConstraintSetBigYBitReversed[3], // D(Y, alpha)
			permConstraintSetBigYBitReversed[0], // S1(Y, alpha)
			permConstraintSetBigYBitReversed[1], // S2(Y, alpha)
			permConstraintSetBigYBitReversed[2], // S3(Y, alpha)
			permConstraintSetBigYBitReversed[3], // S4(Y, alpha)
			permConstraintSetBigYBitReversed[4], // Z(Y, alpha)
			permConstraintSetBigYBitReversed[5], // Z(Y, mu*alpha)
			eta,
			gamma,
			alpha,
		)
		close(chPermConstraint)
	}()

	hxSetCanonicalY, hxSetBigYBitReversed := computeCanonicalAndBigFromSmallY(
		[][]fr.Element{evalsXOnAlpha[0]}, // Hx(Y, alpha)
		globalDomain[0],
		globalDomain[1],
	)
	hxCanonicalY, hxBigYBitReversed := hxSetCanonicalY[0], hxSetBigYBitReversed[0]
	hxSetCanonicalY = nil
	hxSetBigYBitReversed = nil

	// compute Hy in canonical form
	<-chPermConstraint
	<-chGateConstraint

	hyCanonical1, hyCanonical2, hyCanonical3, hyCanonical4 := computeQuotientCanonicalY(pk,
		gateConstraintBigYBitReversed,
		permConstraintBigYBitReversed,
		permConstraintSetBigYBitReversed[4], // Z(Y, alpha)
		hxBigYBitReversed,
		lambda,
		alpha,
	)

	// compute kzg commitments of Hy1, Hy2, Hy3 and Hy4
	if err := commitToQuotientOnY(hyCanonical1, hyCanonical2, hyCanonical3, hyCanonical4, proof, globalSRS); err != nil {
		return nil, err
	}
	// derive beta
	beta, err := deriveRandomness(&fs, "beta", &proof.Hy[0], &proof.Hy[1], &proof.Hy[2], &proof.Hy[3])
	if err != nil {
		return nil, err
	}

	var openingPolysCanonicalY [][]fr.Element
	openingPolysCanonicalY = append(openingPolysCanonicalY, hxCanonicalY)
	openingPolysCanonicalY = append(openingPolysCanonicalY, gateConstraintSetCanonicalY...)
	openingPolysCanonicalY = append(openingPolysCanonicalY, permConstraintSetCanonicalY...)

	// foldedHy = Hy1 + (beta**M)*Hy2 + (beta**(2M))*Hy3 + (beta**(3M))*Hy4
	var bBetaPowerM big.Int
	bSize.SetUint64(globalDomain[0].Cardinality)
	var betaPowerM fr.Element
	betaPowerM.Exp(beta, &bSize)
	betaPowerM.ToBigIntRegular(&bBetaPowerM)
	foldedHyDigest := proof.Hy[3]                                      // Hy4
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM) // (beta**M)*Hy4
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[2])                  // (beta**M)*Hy4 + Hy3
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM) // (beta**(2M))*Hy4 + (beta**M)*Hy3
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[1])                  // (beta**(2M))*Hy4 + (beta**M)*Hy3 + Hy2
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM) // (beta**(3M))*Hy4 + (beta**(2M))*Hy3 + (beta**M)*Hy2
	foldedHyDigest.Add(&foldedHyDigest, &proof.Hy[0])                  // (beta**(3M))*Hy4 + (beta**(2M))*Hy3 + (beta**M)*Hy2 + Hy1
	foldedHy := hyCanonical4
	utils.Parallelize(len(foldedHy), func(start, end int) {
		for i := start; i < end; i++ {
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)      // (beta**M)*Hy4
			foldedHy[i].Add(&foldedHy[i], &hyCanonical3[i]) // (beta**M)*Hy4 + Hy3
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)      // (beta**(2M))*Hy4 + (beta**M)*Hy3
			foldedHy[i].Add(&foldedHy[i], &hyCanonical2[i]) // (beta**(2M))*Hy4 + (beta**M)*Hy3 + Hy2
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)      // (beta**(3M))*Hy4 + (beta**(2M))*Hy3 + (beta**M)*Hy2
			foldedHy[i].Add(&foldedHy[i], &hyCanonical1[i]) // (beta**(3M))*Hy4 + (beta**(2M))*Hy3 + (beta**M)*Hy2 + Hy1
		}
	})

	openingPolysCanonicalY = append(openingPolysCanonicalY, foldedHy)

	// DBG check whether constraints are satisfied
	evalsOnBeta := evalPolynomialsAtPoint(openingPolysCanonicalY, beta)
	if err := checkConstraintY(pk.Vk,
		evalsOnBeta,
		gamma,
		eta,
		lambda,
		alpha,
		beta,
	); err != nil {
		return nil, err
	}

	var digestsY []curve.G1Affine
	digestsY = append(digestsY, proof.PartialBatchedProof.ClaimedDigests[:12]...)
	digestsY = append(digestsY, proof.PartialBatchedShiftedProof.ClaimedDigests[0]) // Comm(D(Y, mu*alpha))
	digestsY = append(digestsY, proof.PartialBatchedProof.ClaimedDigests[12:]...)
	digestsY = append(digestsY, proof.PartialBatchedShiftedProof.ClaimedDigests[1]) // Comm(Z(Y, mu*alpha))
	digestsY = append(digestsY, foldedHyDigest)

	proof.BatchedProof, err = kzg.BatchOpenSinglePoint(
		openingPolysCanonicalY,
		digestsY,
		beta,
		hFunc,
		globalSRS,
	)
	if err != nil {
		return nil, err
	}
	return proof, nil
}

// eval evaluates c at p
func eval(c []fr.Element, p fr.Element) fr.Element {
	var r fr.Element
	for i := len(c) - 1; i >= 0; i-- {
		r.Mul(&r, &p).Add(&r, &c[i])
	}
	return r
}

func evalPolynomialsAtPoint(polys [][]fr.Element, point fr.Element) []fr.Element {
	var wg sync.WaitGroup
	wg.Add(len(polys))

	res := make([]fr.Element, len(polys))
	for i := range polys {
		go func(index int) {
			res[index] = eval(polys[index], point)
			wg.Done()
		}(i)
	}
	wg.Wait()
	return res
}

func commitToLROD(bcl, bcr, bco, bcd []fr.Element, proof *Proof, srs *dkzg.SRS) error {
	if len(proof.LROD) != 4 {
		return fmt.Errorf("wrong number of commitment")
	}

	n := runtime.NumCPU() / 2
	bc := [][]fr.Element{bcl, bcr, bco, bcd}
	var err error
	for i := range proof.LROD {
		proof.LROD[i], err = dkzg.Commit(bc[i], srs, n)
		if err != nil {
			return err
		}
	}

	return nil
}

func commitToQuotientX(h1, h2, h3, h4 []fr.Element, proof *Proof, srs *dkzg.SRS) error {
	if len(proof.Hx) != 4 {
		return fmt.Errorf("wrong number of Hx digest")
	}
	n := runtime.NumCPU() / 2
	var err error
	hs := [][]fr.Element{h1, h2, h3, h4}
	for i := 0; i < 4; i++ {
		if proof.Hx[i], err = dkzg.Commit(hs[i], srs, n); err != nil {
			return err
		}
	}
	return nil
}

func commitToQuotientOnY(h1, h2, h3, h4 []fr.Element, proof *Proof, srs *kzg.SRS) error {
	n := runtime.NumCPU() / 2
	var err0, err1, err2, err3 error
	chCommit0 := make(chan struct{}, 1)
	chCommit1 := make(chan struct{}, 1)
	chCommit2 := make(chan struct{}, 1)
	go func() {
		proof.Hy[0], err0 = kzg.Commit(h1, srs, n)
		close(chCommit0)
	}()
	go func() {
		proof.Hy[1], err1 = kzg.Commit(h2, srs, n)
		close(chCommit1)
	}()
	go func() {
		proof.Hy[2], err2 = kzg.Commit(h3, srs, n)
		close(chCommit2)
	}()
	if proof.Hy[3], err3 = kzg.Commit(h4, srs, n); err3 != nil {
		return err3
	}
	<-chCommit0
	<-chCommit1
	<-chCommit2

	if err0 != nil {
		return err0
	}
	if err1 != nil {
		return err1
	}

	return err2
}

func computeLRODCanonicalX(ll, lr, lo, ld []fr.Element, domain *fft.Domain) (cl, cr, co, cd []fr.Element, err error) {
	cl = make([]fr.Element, domain.Cardinality)
	cr = make([]fr.Element, domain.Cardinality)
	co = make([]fr.Element, domain.Cardinality)
	cd = make([]fr.Element, domain.Cardinality)

	chDone := make(chan error, 2)

	go func() {
		copy(cl, ll)
		domain.FFTInverse(cl, fft.DIF)
		fft.BitReverse(cl)
		chDone <- nil
	}()
	go func() {
		copy(cr, lr)
		domain.FFTInverse(cr, fft.DIF)
		fft.BitReverse(cr)
		chDone <- nil
	}()
	go func() {
		copy(co, lo)
		domain.FFTInverse(co, fft.DIF)
		fft.BitReverse(co)
		chDone <- nil
	}()
	copy(cd, ld)
	domain.FFTInverse(cd, fft.DIF)
	fft.BitReverse(cd)
	err = <-chDone
	if err != nil {
		return
	}
	err = <-chDone
	if err != nil {
		return
	}
	err = <-chDone
	return
}

// blindPoly blinds a polynomial by adding a Q(X)*(X**degree-1), where deg Q = order.
//
// * cp polynomial in canonical form
// * rou root of unity, meaning the blinding factor is multiple of X**rou-1
// * bo blinding order,  it's the degree of Q, where the blinding is Q(X)*(X**degree-1)
//
// WARNING:
// pre condition degree(cp) ⩽ rou + bo
// pre condition cap(cp) ⩾ int(totalDegree + 1)
func blindPoly(cp []fr.Element, rou, bo uint64) ([]fr.Element, error) {

	// degree of the blinded polynomial is max(rou+order, cp.Degree)
	totalDegree := rou + bo

	// re-use cp
	res := cp[:totalDegree+1]

	// random polynomial
	blindingPoly := make([]fr.Element, bo+1)
	for i := uint64(0); i < bo+1; i++ {
		if _, err := blindingPoly[i].SetRandom(); err != nil {
			return nil, err
		}
	}

	// blinding
	for i := uint64(0); i < bo+1; i++ {
		res[i].Sub(&res[i], &blindingPoly[i])
		res[rou+i].Add(&res[rou+i], &blindingPoly[i])
	}

	return res, nil

}

// readLRODSmallDomainX extracts the solution l, r, o, d, and returns it in lagrange form.
func readLRODSmallDomainX(pk *ProvingKey) (L []fr.Element, R []fr.Element, O []fr.Element, D []fr.Element) {
	size := int(pk.Domain[0].Cardinality)
	L = make([]fr.Element, size)
	R = make([]fr.Element, size)
	O = make([]fr.Element, size)
	D = make([]fr.Element, size)
	for i := 0; i < size; i++ {
		L[i].SetInt64(int64(readInt()))
	}
	for i := 0; i < size; i++ {
		R[i].SetInt64(int64(readInt()))
	}
	for i := 0; i < size; i++ {
		O[i].SetInt64(int64(readInt()))
	}
	for i := 0; i < size; i++ {
		D[i].SetInt64(int64(readInt()))
	}
	return
}

// computeZ computes z, in canonical basis, where:
//
// * z of degree n (domainNum.Cardinality)
// * z(1)=1
// 							       (l(g**k)+eta*(g**k)+gamma)*(r(g**k)+eta*u*(g**k)+gamma)*(o(g**k)+eta*(mu**2)*(g**k)+gamma)*(d(g**k)+eta*(mu**3)*(g**k)+gamma)
// * for i>0: z(g**i) = prod_{k<i} -----------------------------------------------------------------------------------------------------------------------------
//							         (l(g**k)+eta*s1(g**k)+gamma)*(r(g**k)+eta*s2(g**k)+gamma)*(o(g**k)+eta*s3(g**k)+gamma)*(d(g**k)+eta*s4(g**k)+gamma)
//
//	* l, r, o, d are the solution in Lagrange basis, evaluated on the small domain
func computeZCanonicalX(l, r, o, d []fr.Element, pk *ProvingKey, eta, gamma fr.Element) ([]fr.Element, error) {

	// note that z has more capacity has its memory is reused for blinded z later on
	z := make([]fr.Element, pk.Domain[0].Cardinality)
	nbElmts := int(pk.Domain[0].Cardinality)
	gInv := make([]fr.Element, pk.Domain[0].Cardinality)

	z[0].SetOne()
	gInv[0].SetOne()

	evaluationIDSmallDomain := getIDSmallDomain(&pk.Domain[0])

	utils.Parallelize(nbElmts-1, func(start, end int) {

		var f [4]fr.Element
		var g [4]fr.Element

		for i := start; i < end; i++ {

			f[0].Mul(&evaluationIDSmallDomain[i], &eta).Add(&f[0], &l[i]).Add(&f[0], &gamma)
			f[1].Mul(&evaluationIDSmallDomain[i+nbElmts], &eta).Add(&f[1], &r[i]).Add(&f[1], &gamma)
			f[2].Mul(&evaluationIDSmallDomain[i+2*nbElmts], &eta).Add(&f[2], &o[i]).Add(&f[2], &gamma)
			f[3].Mul(&evaluationIDSmallDomain[i+3*nbElmts], &eta).Add(&f[3], &d[i]).Add(&f[3], &gamma)

			g[0].Mul(&evaluationIDSmallDomain[pk.Permutation[i]], &eta).Add(&g[0], &l[i]).Add(&g[0], &gamma)
			g[1].Mul(&evaluationIDSmallDomain[pk.Permutation[i+nbElmts]], &eta).Add(&g[1], &r[i]).Add(&g[1], &gamma)
			g[2].Mul(&evaluationIDSmallDomain[pk.Permutation[i+2*nbElmts]], &eta).Add(&g[2], &o[i]).Add(&g[2], &gamma)
			g[3].Mul(&evaluationIDSmallDomain[pk.Permutation[i+3*nbElmts]], &eta).Add(&g[3], &d[i]).Add(&g[3], &gamma)

			f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2]).Mul(&f[0], &f[3])
			g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2]).Mul(&g[0], &g[3])

			gInv[i+1] = g[0]
			z[i+1] = f[0]
		}
	})

	gInv = fr.BatchInvert(gInv)
	for i := 1; i < nbElmts; i++ {
		z[i].Mul(&z[i], &z[i-1]).
			Mul(&z[i], &gInv[i])
	}

	pk.Domain[0].FFTInverse(z, fft.DIF)
	fft.BitReverse(z)

	return z, nil

}

// evaluateGateConstraintBigXBitReversed computes the evaluation of
// ql(X)L(X) + qr(X)r(X) + qm(X)l(X)r(X) + qo(X)o(X) + qk(X)
// on the big domain coset.
func evaluateGateConstraintBigXBitReversed(pk *ProvingKey, lBigXBR, rBigXBR, oBigXBR, dBigXBR, qkCX []fr.Element) []fr.Element {
	var qlBigXBR, qrBigXBR, qmBigXBR, qoBigXBR, qdBigXBR, qndBigXBR, qkBigXBR []fr.Element
	var wg sync.WaitGroup
	wg.Add(6)

	go func() {
		qlBigXBR = evaluateBigBitReversed(pk.Ql, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		qrBigXBR = evaluateBigBitReversed(pk.Qr, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		qmBigXBR = evaluateBigBitReversed(pk.Qm, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		qoBigXBR = evaluateBigBitReversed(pk.Qo, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		qdBigXBR = evaluateBigBitReversed(pk.Qd, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		qndBigXBR = evaluateBigBitReversed(pk.Qnd, &pk.Domain[1])
		wg.Done()
	}()
	qkBigXBR = evaluateBigBitReversed(qkCX, &pk.Domain[1])
	wg.Wait()

	// needed to shift evalD
	toShift := int(pk.Domain[1].Cardinality / pk.Domain[0].Cardinality)
	nbElmts := int(pk.Domain[1].Cardinality)
	utils.Parallelize(len(qkBigXBR), func(start, end int) {
		var t0, t1 fr.Element
		for i := start; i < end; i++ {
			// (qm * r + ql) * l
			t1.Mul(&qmBigXBR[i], &rBigXBR[i])
			t1.Add(&t1, &qlBigXBR[i])
			t1.Mul(&t1, &lBigXBR[i])

			// + qr * r
			t0.Mul(&qrBigXBR[i], &rBigXBR[i])
			t0.Add(&t0, &t1)

			// + qo * o
			t1.Mul(&qoBigXBR[i], &oBigXBR[i])
			t0.Add(&t0, &t1)

			// + qd * d
			t1.Mul(&qdBigXBR[i], &dBigXBR[i])
			t0.Add(&t0, &t1)

			// + qnd * d_next
			t1.Mul(&qndBigXBR[i], &dBigXBR[(i+toShift)%nbElmts])
			t0.Add(&t0, &t1)

			// + qk
			qkBigXBR[i].Add(&t0, &qkBigXBR[i])
		}
	})

	return qkBigXBR
}

// evaluateGateConstraintBigYBitReversed computes the evaluation of
// Ql(Y, alpha)L(Y, alpha) + Qr(Y, alpha)R(Y, alpha) + Qm(Y, alpha)L(Y, alpha)R(Y, alpha)
// + Qo(Y, alpha)O(Y, alpha) +Qd(Y, alpha)D(Y, alpha) + Qnd(Y, alpha)D(Y, mu*alpha)
// + Qk(Y, alpha) on the big domain coset in terms of Y.
func evaluateGateConstraintBigYBitReversed(lBigYBR, rBigYBR, oBigYBR, dBigYBR, dShiftedBigYBR, qlBigYBR, qrBigYBR, qmBigYBR, qoBigYBR, qdBigYBR, qndBigYBR, qkBigYBR []fr.Element) []fr.Element {
	res := make([]fr.Element, len(lBigYBR))
	utils.Parallelize(len(qkBigYBR), func(start, end int) {
		var t0, t1 fr.Element
		for i := start; i < end; i++ {
			// (qm * r + ql) * l
			t1.Mul(&qmBigYBR[i], &rBigYBR[i])
			t1.Add(&t1, &qlBigYBR[i])
			t1.Mul(&t1, &lBigYBR[i])

			// + qr * r
			t0.Mul(&qrBigYBR[i], &rBigYBR[i])
			t0.Add(&t0, &t1)

			// + qo * o
			t1.Mul(&qoBigYBR[i], &oBigYBR[i])
			t0.Add(&t0, &t1)

			// + qd * d
			t1.Mul(&qdBigYBR[i], &dBigYBR[i])
			t0.Add(&t0, &t1)

			// + qnd * d_next
			t1.Mul(&qndBigYBR[i], &dShiftedBigYBR[i])
			t0.Add(&t0, &t1)
			res[i].Add(&t0, &qkBigYBR[i])
		}
	})

	return res
}

// evaluatePermConstraintBigXBitReversed computes the evaluation of
// z(mu*X) * (l(X)+eta*s1(X)+gamma) * (r(X))+eta*s2(X)+gamma) * (o(X))+eta*s3(X)+gamma)
// - z(X) * (l(X)+eta*X+gamma) * (r(X)+eta*u*X+gamma) * (o(X)+eta*(u**2)*X+gamma)
// on the big domain (coset).
func evaluatePermConstraintBigXBitReversed(pk *ProvingKey, lBigXBR, rBigXBR, oBigXBR, dBigXBR, zBigXBR []fr.Element, eta, gamma fr.Element) []fr.Element {
	nbElmts := int(pk.Domain[1].Cardinality)

	// computes
	res := make([]fr.Element, pk.Domain[1].Cardinality)

	nn := uint64(64 - bits.TrailingZeros64(uint64(nbElmts)))

	// needed to shift evalZ
	toShift := int(pk.Domain[1].Cardinality / pk.Domain[0].Cardinality)

	var cosetShift, cosetShiftSquare, cosetShiftCube fr.Element
	cosetShift.Set(&pk.Vk.CosetShift)
	cosetShiftSquare.Square(&pk.Vk.CosetShift)
	cosetShiftCube.Mul(&cosetShift, &cosetShiftSquare)

	utils.Parallelize(int(pk.Domain[1].Cardinality), func(start, end int) {

		// eta * (g**start)
		var evaluationIDBigDomain fr.Element
		evaluationIDBigDomain.Exp(pk.Domain[1].Generator, big.NewInt(int64(start))).
			Mul(&evaluationIDBigDomain, &pk.Domain[1].FrMultiplicativeGen).
			Mul(&evaluationIDBigDomain, &eta)

		var f [4]fr.Element
		var g [4]fr.Element

		for i := start; i < end; i++ {

			_i := bits.Reverse64(uint64(i)) >> nn
			_is := bits.Reverse64(uint64((i+toShift)%nbElmts)) >> nn

			f[0].Add(&evaluationIDBigDomain, &lBigXBR[_i]).Add(&f[0], &gamma)
			f[1].Mul(&evaluationIDBigDomain, &cosetShift).Add(&f[1], &rBigXBR[_i]).Add(&f[1], &gamma)
			f[2].Mul(&evaluationIDBigDomain, &cosetShiftSquare).Add(&f[2], &oBigXBR[_i]).Add(&f[2], &gamma)
			f[3].Mul(&evaluationIDBigDomain, &cosetShiftCube).Add(&f[3], &dBigXBR[_i]).Add(&f[3], &gamma)

			g[0].Mul(&pk.EvaluationPermutationBigDomainBitReversed[_i], &eta).Add(&g[0], &lBigXBR[_i]).Add(&g[0], &gamma)
			g[1].Mul(&pk.EvaluationPermutationBigDomainBitReversed[int(_i)+nbElmts], &eta).Add(&g[1], &rBigXBR[_i]).Add(&g[1], &gamma)
			g[2].Mul(&pk.EvaluationPermutationBigDomainBitReversed[int(_i)+2*nbElmts], &eta).Add(&g[2], &oBigXBR[_i]).Add(&g[2], &gamma)
			g[3].Mul(&pk.EvaluationPermutationBigDomainBitReversed[int(_i)+3*nbElmts], &eta).Add(&g[3], &dBigXBR[_i]).Add(&g[3], &gamma)

			f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2]).Mul(&f[0], &f[3]).Mul(&f[0], &zBigXBR[_i])
			g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2]).Mul(&g[0], &g[3]).Mul(&g[0], &zBigXBR[_is])

			res[_i].Sub(&g[0], &f[0])

			evaluationIDBigDomain.Mul(&evaluationIDBigDomain, &pk.Domain[1].Generator)
		}
	})

	return res
}

// evaluatePermConstraintBigYBitReversed computes the evaluation of
// Z(Y, mu*alpha)G1(Y, alpha)G2(Y, alpha)G3(Y, alpha) - Z(Y, alpha)F1(Y, alpha)F2(Y, alpha)F3(Y, alpha)
// on the big domain coset.
// where G1 = L(Y, alpha) + eta*S1(Y, alpha) + gamma
//       G2 = R(Y, alpha) + eta*S2(Y, alpha) + gamma
//       G3 = O(Y, alpha) + eta*S3(Y, alpha) + gamma
//       G4 = D(Y, alpha) + eta*S4(Y, alpha) + gamma
//       F1 = L(Y, alpha) + eta*alpha + gamma
//       F2 = R(Y, alpha) + eta*U*alpha + gamma
//       F3 = O(Y, alpha) + eta*U**2*alpha + gamma
//       F4 = D(Y, alpha) + eta*U**3*alpha + gamma
func evaluatePermConstraintBigYBitReversed(pk *ProvingKey, lBigYBR, rBigYBR, oBigYBR, dBigYBR, s1BigYBR, s2BigYBR, s3BigYBR, s4BigYBR, zBigYBR, zmuBigYBR []fr.Element, eta, gamma, alpha fr.Element) []fr.Element {
	res := make([]fr.Element, globalDomain[1].Cardinality)

	var etaAlpha, etaAlphaCosetShift, etaAlphaCosetShiftSquare, etaAlphaCosetShiftCube fr.Element
	etaAlpha.Mul(&alpha, &eta)                                               // eta*alpha
	etaAlphaCosetShift.Mul(&etaAlpha, &pk.Vk.CosetShift)                     // eta*alpha*u
	etaAlphaCosetShiftSquare.Mul(&etaAlphaCosetShift, &pk.Vk.CosetShift)     // eta*alpha*u*u
	etaAlphaCosetShiftCube.Mul(&etaAlphaCosetShiftSquare, &pk.Vk.CosetShift) // eta * alpha*u*u*u

	utils.Parallelize(int(globalDomain[1].Cardinality), func(start, end int) {

		var f [4]fr.Element
		var g [4]fr.Element

		for i := start; i < end; i++ {
			f[0].Add(&etaAlpha, &lBigYBR[i]).Add(&f[0], &gamma)
			f[1].Add(&etaAlphaCosetShift, &rBigYBR[i]).Add(&f[1], &gamma)
			f[2].Add(&etaAlphaCosetShiftSquare, &oBigYBR[i]).Add(&f[2], &gamma)
			f[3].Add(&etaAlphaCosetShiftCube, &dBigYBR[i]).Add(&f[3], &gamma)

			g[0].Mul(&s1BigYBR[i], &eta).Add(&g[0], &lBigYBR[i]).Add(&g[0], &gamma)
			g[1].Mul(&s2BigYBR[i], &eta).Add(&g[1], &rBigYBR[i]).Add(&g[1], &gamma)
			g[2].Mul(&s3BigYBR[i], &eta).Add(&g[2], &oBigYBR[i]).Add(&g[2], &gamma)
			g[2].Mul(&s4BigYBR[i], &eta).Add(&g[3], &dBigYBR[i]).Add(&g[3], &gamma)

			f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2]).Mul(&f[0], &f[3]).Mul(&f[0], &zBigYBR[i])
			g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2]).Mul(&g[0], &g[3]).Mul(&g[0], &zmuBigYBR[i])

			res[i].Sub(&g[0], &f[0])
		}
	})

	return res
}

// evaluateBigBitReversed evaluates poly (canonical form) of degree n<n' where
// n'=domainH.Cardinality on the big domain (coset).
//
// Puts the result in res of size n'.
func evaluateBigBitReversed(poly []fr.Element, domainH *fft.Domain) []fr.Element {
	res := make([]fr.Element, domainH.Cardinality)
	copy(res, poly)
	domainH.FFT(res, fft.DIF, true)
	return res
}

// computeCanonicalAndBigFromSmallY evaluates poly (lagrange on small domain)
// on big domain coset.
func computeCanonicalAndBigFromSmallY(smallEvals [][]fr.Element, smallDomain *fft.Domain, bigDomain *fft.Domain) ([][]fr.Element, [][]fr.Element) {
	num := len(smallEvals)
	polys := make([][]fr.Element, num)
	bigEvals := make([][]fr.Element, num)

	chPolysDone := make([]chan bool, num)
	chBigEvalsDone := make([]chan bool, num)
	for i := 0; i < num; i++ {
		chPolysDone[i] = make(chan bool, 1)
		chBigEvalsDone[i] = make(chan bool, 1)
	}

	// create and spawn nums goroutines
	for i := 0; i < num; i++ {
		go func(index int, finished chan bool) {
			polys[index] = make([]fr.Element, smallDomain.Cardinality)
			copy(polys[index], smallEvals[index])
			smallDomain.FFTInverse(polys[index], fft.DIF)
			fft.BitReverse(polys[index])
			close(finished)
		}(i, chPolysDone[i])

		go func(index int, finished chan bool) {
			<-chPolysDone[index]
			bigEvals[index] = evaluateBigBitReversed(polys[index], bigDomain)
			close(finished)
		}(i, chBigEvalsDone[i])
	}

	// wait for all goroutines to finish
	for i := 0; i < num; i++ {
		<-chBigEvalsDone[i]
	}

	return polys, bigEvals
}

// evaluateXnMinusOneBig evalutes Xᵐ-1 on DomainBig coset
func evaluateXnMinusOneBig(domainBig, domainSmall *fft.Domain) []fr.Element {

	ratio := domainBig.Cardinality / domainSmall.Cardinality

	res := make([]fr.Element, ratio)

	expo := big.NewInt(int64(domainSmall.Cardinality))
	res[0].Exp(domainBig.FrMultiplicativeGen, expo)

	var t fr.Element
	t.Exp(domainBig.Generator, big.NewInt(int64(domainSmall.Cardinality)))

	for i := 1; i < int(ratio); i++ {
		res[i].Mul(&res[i-1], &t)
	}

	var one fr.Element
	one.SetOne()
	for i := 0; i < int(ratio); i++ {
		res[i].Sub(&res[i], &one)
	}

	return res
}

// computeQuotientCanonicalX computes hx in canonical form, split as
// hx1 + (X**N)hx2 + (X**(2N))h3 + (X**(3N))h4 such that
//
// ql(X)l(X)+qr(X)r(X)+qm(X)l(X)r(X)+qo(X)o(X)+qd(X)d(X)+qnd(X)d(mu*X)+qk(X)
// + lambda * (z(mu*X)*g1(X)*g2(X)*g3(X)*g4(X)-z(X)*f1(X)*f2(X)*f3(X)*f4(X))
// + (lambda**2) * L1(X)*(z(X)-1)
// = hx(X)Zn(X)
func computeQuotientCanonicalX(pk *ProvingKey, gateConstraintBigXBitReversed, permConstraintBigXBitReversed, zBigXBitReversed []fr.Element, lambda fr.Element) ([]fr.Element, []fr.Element, []fr.Element, []fr.Element) {

	h := make([]fr.Element, pk.Domain[1].Cardinality)

	XnMinusOneInvBig := evaluateXnMinusOneBig(&pk.Domain[1], &pk.Domain[0])
	XnMinusOneInvBig = fr.BatchInvert(XnMinusOneInvBig)

	permFirstConstraintBigXBitReversed := make([]fr.Element, pk.Domain[1].Cardinality)
	for i := 0; i < int(pk.Domain[0].Cardinality); i++ {
		permFirstConstraintBigXBitReversed[i].Set(&pk.Domain[0].CardinalityInv)
	}
	pk.Domain[1].FFT(permFirstConstraintBigXBitReversed, fft.DIF, true)

	nn := uint64(64 - bits.TrailingZeros64(pk.Domain[1].Cardinality))

	var one fr.Element
	one.SetOne()

	ratio := pk.Domain[1].Cardinality / pk.Domain[0].Cardinality

	utils.Parallelize(int(pk.Domain[1].Cardinality), func(start, end int) {
		var t fr.Element
		for i := uint64(start); i < uint64(end); i++ {

			_i := bits.Reverse64(i) >> nn

			t.Sub(&zBigXBitReversed[_i], &one) // evaluates L₁(X)*(Z(X)-1) on a coset of the big domain
			h[_i].Mul(&permFirstConstraintBigXBitReversed[_i], &lambda).Mul(&h[_i], &t).
				Add(&h[_i], &permConstraintBigXBitReversed[_i]).
				Mul(&h[_i], &lambda).
				Add(&h[_i], &gateConstraintBigXBitReversed[_i]).
				Mul(&h[_i], &XnMinusOneInvBig[i%ratio])
		}
	})

	pk.Domain[1].FFTInverse(h, fft.DIT, true)

	domainSize := pk.Domain[0].Cardinality
	h1 := h[:domainSize]
	h2 := h[domainSize : 2*(domainSize)]
	h3 := h[2*(domainSize) : 3*(domainSize)]
	h4 := h[3*(domainSize) : 4*(domainSize)]

	return h1, h2, h3, h4

}

// computeQuotientCanonicalY computes Hy in canonical form, split as
// Hy1 + (Y**M)Hy2 + (Y**(2M))Hy3 such that
//
// Ql(Y, alpha)L(Y, alpha)+Qr(Y, alpha)R(Y, alpha)+Qm(Y, alpha)L(Y, alpha)R(Y, alpha)
// 		+Qo(Y, alpha)O(Y, alpha)+Qd(Y, alpha)*D(Y, alpha)
//		+Qnd(Y, alpha)D(Y, mu*alpha)+Qk(Y, alpha)
// + lambda * (Z(Y, mu*alpha)*G1(Y, alpha)*G2(Y, alpha)*G3(Y, alpha)*G4(Y, alpha)
//	 - Z(Y, alpha)*F1(Y, alpha)*F2(Y, alpha)*F3(Y, alpha)*F4(Y, alpha))
// + lambda**2 * L1(alpha)*(Z(Y, alpha) - 1)
// - Hx(Y, alpha)Z(X) = Hy(Y)Z(Y)
func computeQuotientCanonicalY(pk *ProvingKey, gateConstraintBigYBitReversed, permConstraintBigYBitReversed, ZBigYBitReversed, hxBigYBitReversed []fr.Element, lambda, alpha fr.Element) ([]fr.Element, []fr.Element, []fr.Element, []fr.Element) {
	h := make([]fr.Element, globalDomain[1].Cardinality)

	evaluationXmMinusOneInverse := evaluateXnMinusOneBig(globalDomain[1], globalDomain[0])
	evaluationXmMinusOneInverse = fr.BatchInvert(evaluationXmMinusOneInverse)

	nn := uint64(64 - bits.TrailingZeros64(globalDomain[1].Cardinality))
	var one fr.Element
	one.SetOne()

	// L1(alpha)
	var lagrangeAlpha, den fr.Element
	nbElmt := int64(pk.Domain[0].Cardinality)
	lagrangeAlpha.Set(&alpha).
		Exp(lagrangeAlpha, big.NewInt(nbElmt)).
		Sub(&lagrangeAlpha, &one)
	den.Sub(&alpha, &one).
		Inverse(&den)
	lagrangeAlpha.Mul(&lagrangeAlpha, &den).
		Mul(&lagrangeAlpha, &pk.Domain[0].CardinalityInv)

	var vanishingX fr.Element
	vanishingX.Exp(alpha, big.NewInt(int64(pk.Domain[0].Cardinality)))
	vanishingX.Sub(&vanishingX, &one)

	ratio := globalDomain[1].Cardinality / globalDomain[0].Cardinality

	utils.Parallelize(int(globalDomain[1].Cardinality), func(start, end int) {
		var permFirstConstraintBigYBitReversed, vHxBigYBitReversed fr.Element
		for i := uint64(start); i < uint64(end); i++ {

			_i := bits.Reverse64(i) >> nn

			permFirstConstraintBigYBitReversed.Sub(&ZBigYBitReversed[_i], &one).Mul(&permFirstConstraintBigYBitReversed, &lagrangeAlpha)
			vHxBigYBitReversed.Mul(&hxBigYBitReversed[_i], &vanishingX)
			h[_i].Mul(&permFirstConstraintBigYBitReversed, &lambda).
				Add(&h[_i], &permConstraintBigYBitReversed[_i]).
				Mul(&h[_i], &lambda).
				Add(&h[_i], &gateConstraintBigYBitReversed[_i]).
				Sub(&h[_i], &vHxBigYBitReversed).
				Mul(&h[_i], &evaluationXmMinusOneInverse[i%ratio])
		}
	})

	globalDomain[1].FFTInverse(h, fft.DIT, true)

	h1 := h[:globalDomain[0].Cardinality]
	h2 := h[globalDomain[0].Cardinality : 2*globalDomain[0].Cardinality]
	h3 := h[2*globalDomain[0].Cardinality : 3*globalDomain[0].Cardinality]
	h4 := h[3*globalDomain[0].Cardinality : 4*globalDomain[0].Cardinality]
	return h1, h2, h3, h4
}

// checkConstraintX checks that the constraint is satisfied
func checkConstraintX(pk *ProvingKey, evalsXOnAlpha [][]fr.Element, evalsXOnShiftedAlpha [][]fr.Element, gamma, eta, lambda, alpha fr.Element) error {
	for k := 0; k < int(mpi.WorldSize); k++ {
		// unpack vector evalsXOnAlpha on hx, l, r, o, ql, qr, qm, qo, qk, s1, s2, s3, z
		hx := evalsXOnAlpha[0][k]
		l := evalsXOnAlpha[1][k]
		r := evalsXOnAlpha[2][k]
		o := evalsXOnAlpha[3][k]
		d := evalsXOnAlpha[4][k]
		ql := evalsXOnAlpha[5][k]
		qr := evalsXOnAlpha[6][k]
		qm := evalsXOnAlpha[7][k]
		qo := evalsXOnAlpha[8][k]
		qd := evalsXOnAlpha[9][k]
		qnd := evalsXOnAlpha[10][k]
		qk := evalsXOnAlpha[11][k]
		s1 := evalsXOnAlpha[12][k]
		s2 := evalsXOnAlpha[13][k]
		s3 := evalsXOnAlpha[14][k]
		s4 := evalsXOnAlpha[15][k]
		z := evalsXOnAlpha[16][k]
		dmu := evalsXOnShiftedAlpha[0][k]
		zmu := evalsXOnShiftedAlpha[1][k]

		// first part: individual constraints
		var firstPart fr.Element
		ql.Mul(&ql, &l)
		qr.Mul(&qr, &r)
		qm.Mul(&qm, &l).Mul(&qm, &r)
		qo.Mul(&qo, &o)
		qd.Mul(&qd, &d)
		qnd.Mul(&qnd, &dmu)
		firstPart.Add(&ql, &qr).Add(&firstPart, &qm).Add(&firstPart, &qo).Add(&firstPart, &qd).Add(&firstPart, &qnd).Add(&firstPart, &qk)

		// second part:
		// (L(beta, alpha)+eta*S1(beta, alpha)+gamma)*(R(beta, alpha)+eta*S2(beta, alpha)+gamma)*(O(beta, alpha)+eta*S3(alpha)+gamma)*(D(beta, alpha)+eta*S4(alpha)+gamma) * Z(beta,mu*alpha)
		// - (L(beta, alpha)+eta*id1(beta, alpha)+gamma)*(R(beta, alpha)+eta*id2(beta, alpha)+gamma)*(O(beta, alpha)+eta*id3(beta, alpha)+gamma)*(D(beta, alpha)+eta*id4(beta, alpha)+gamma) * Z(beta, alpha)
		s1.Mul(&s1, &eta).Add(&s1, &l).Add(&s1, &gamma)
		s2.Mul(&s2, &eta).Add(&s2, &r).Add(&s2, &gamma)
		s3.Mul(&s3, &eta).Add(&s3, &o).Add(&s3, &gamma)
		s4.Mul(&s4, &eta).Add(&s4, &d).Add(&s4, &gamma)
		s1.Mul(&s1, &s2).Mul(&s1, &s3).Mul(&s1, &s4).Mul(&s1, &zmu)

		var ualpha, uualpha, uuualpha fr.Element
		ualpha.Mul(&alpha, &pk.Vk.CosetShift)
		uualpha.Mul(&ualpha, &pk.Vk.CosetShift)
		uuualpha.Mul(&uualpha, &pk.Vk.CosetShift)

		var secondPart, tmp fr.Element
		secondPart.Mul(&eta, &alpha).Add(&secondPart, &l).Add(&secondPart, &gamma)
		tmp.Mul(&eta, &ualpha).Add(&tmp, &r).Add(&tmp, &gamma)
		secondPart.Mul(&secondPart, &tmp)
		tmp.Mul(&eta, &uualpha).Add(&tmp, &o).Add(&tmp, &gamma)
		secondPart.Mul(&secondPart, &tmp)
		tmp.Mul(&eta, &uuualpha).Add(&tmp, &d).Add(&tmp, &gamma)
		secondPart.Mul(&secondPart, &tmp).Mul(&secondPart, &z)
		secondPart.Sub(&s1, &secondPart)

		// third part L1(alpha)*(Z(Y, alpha) - 1)
		var thirdPart, one, den fr.Element
		one.SetOne()
		z.Sub(&z, &one)
		nbElmt := int64(pk.Domain[0].Cardinality)
		thirdPart.Set(&alpha).
			Exp(thirdPart, big.NewInt(nbElmt)).
			Sub(&thirdPart, &one)
		den.Sub(&alpha, &one).
			Inverse(&den)
		thirdPart.Mul(&thirdPart, &den).
			Mul(&thirdPart, &pk.Domain[0].CardinalityInv).
			Mul(&thirdPart, &z)

		// Put it all together
		var result fr.Element
		result.Mul(&thirdPart, &lambda).Add(&result, &secondPart).Mul(&result, &lambda).Add(&result, &firstPart)

		var vanishingX fr.Element
		vanishingX.Exp(alpha, big.NewInt(int64(pk.Domain[0].Cardinality)))
		vanishingX.Sub(&vanishingX, &one)

		var vH fr.Element
		vH.Mul(&hx, &vanishingX)
		result.Sub(&result, &vH)

		// if result != 0 return error
		if !result.IsZero() {
			return fmt.Errorf("constraints on X are not satisfied on %d: got %s, want 0", k, result.String())
		}
	}
	return nil
}
