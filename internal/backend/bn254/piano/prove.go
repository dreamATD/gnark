// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package piano

import (
	"crypto/sha256"
	"math/big"
	"math/bits"
	"runtime"
	"sync"
	"time"

	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr/kzg"
	"github.com/consensys/gnark/dkzg"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr/fft"

	bn254witness "github.com/consensys/gnark/internal/backend/bn254/witness"

	"github.com/consensys/gnark/internal/backend/bn254/cs"

	"github.com/consensys/gnark-crypto/fiat-shamir"
	"github.com/consensys/gnark/backend"
	"github.com/consensys/gnark/internal/utils"
	"github.com/consensys/gnark/logger"

	"github.com/sunblaze-ucb/simpleMPI/mpi"
)

var (
	World *mpi.MPIWorld
)

type Proof struct {

	// Commitments to the solution vectors
	LRO [3]dkzg.Digest

	// Commitment to Z, the permutation polynomial
	Z dkzg.Digest

	// Commitments to h1, h2, h3 such that h = h1 + Xh2 + X**2h3 is the quotient polynomial
	// The degree of Hx and Hy are both 3.
	Hx [3]dkzg.Digest
	Hy [3]kzg.Digest

	// Batch partially opening proof of l, r, 0, z, hx1 + alpha*hx2 + alpha**2hx3 on X = alpha
	PartialBatchedProof dkzg.BatchOpeningProof

	// Opening partially proof of z on X = mu*alpha
	PartialZShiftedOpening dkzg.OpeningProof

	// Batch opening proof of a, b, o, z, z_mu, linearilyCombinedIdentities on (alpha, beta)
	BatchedProof kzg.BatchOpeningProof
}

// Prove from the public data
func Prove(spr *cs.SparseR1CS, pk *ProvingKey, fullWitness bn254witness.Witness, opt backend.ProverConfig) (*Proof, error) {

	log := logger.Logger().With().Str("curve", spr.CurveID().String()).Int("nbConstraints", len(spr.Constraints)).Str("backend", "plonk").Logger()
	start := time.Now()
	// pick a hash function that will be used to derive the challenges
	hFunc := sha256.New()

	// create a transcript manager to apply Fiat Shamir
	fs := fiatshamir.NewTranscript(hFunc, "gamma", "eta", "lambda", "alpha", "beta")

	// result
	proof := &Proof{}

	// compute the constraint system solution
	var solution []fr.Element
	var err error
	if solution, err = spr.Solve(fullWitness, opt); err != nil {
		if !opt.Force {
			return nil, err
		} else {
			// we need to fill solution with random values
			var r fr.Element
			_, _ = r.SetRandom()
			for i := spr.NbPublicVariables + spr.NbSecretVariables; i < len(solution); i++ {
				solution[i] = r
				r.Double(&r)
			}
		}
	}

	// query l, r, o in Lagrange basis, not blinded
	lEvalSmallX, rEvalSmallX, oEvalSmallX := evaluateLROSmallDomainX(spr, pk, solution)

	// save ll, lr, lo, and make a copy of them in canonical basis.
	// note that we allocate more capacity to reuse for blinded polynomials
	blindedLCanonicalX, blindedRCanonicalX, blindedOCanonicalX, err := computeBlindedLROCanonicalX(
		lEvalSmallX,
		rEvalSmallX,
		oEvalSmallX,
		&pk.Domain[0])
	if err != nil {
		return nil, err
	}

	// compute kzg commitments of bcl, bcr and bco
	if err := commitToLRO(blindedLCanonicalX, blindedRCanonicalX, blindedOCanonicalX, proof, pk.Vk.KZGSRS); err != nil {
		return nil, err
	}

	// The first challenge is derived using the public data: the commitments to the permutation,
	// the coefficients of the circuit, and the public inputs.
	// derive gamma from the Comm(blinded cl), Comm(blinded cr), Comm(blinded co)
	if err := bindPublicData(&fs, "gamma", *pk.Vk, fullWitness[:spr.NbPublicVariables]); err != nil {
		return nil, err
	}
	bgamma, err := fs.ComputeChallenge("gamma")
	if err != nil {
		return nil, err
	}
	var gamma fr.Element
	gamma.SetBytes(bgamma)

	// Fiat Shamir this
	eta, err := deriveRandomness(&fs, "eta")
	if err != nil {
		return nil, err
	}

	// compute Z, the permutation accumulator polynomial, in canonical basis
	// ll, lr, lo are NOT blinded
	var blindedZCanonicalX []fr.Element
	chZ := make(chan error, 1)
	var lambda fr.Element
	go func() {
		var err error
		blindedZCanonicalX, err = computeBlindedZCanonicalX(
			lEvalSmallX,
			rEvalSmallX,
			oEvalSmallX,
			pk, eta, gamma)
		if err != nil {
			chZ <- err
			close(chZ)
			return
		}

		// commit to the blinded version of z
		// note that we explicitly double the number of tasks for the multi exp in dkzg.Commit
		// this may add additional arithmetic operations, but with smaller tasks
		// we ensure that this commitment is well parallelized, without having a "unbalanced task" making
		// the rest of the code wait too long.
		if proof.Z, err = dkzg.Commit(blindedZCanonicalX, pk.Vk.KZGSRS, runtime.NumCPU()*2); err != nil {
			chZ <- err
			close(chZ)
			return
		}

		// derive lambda from the Comm(l), Comm(r), Comm(o), Com(Z)
		lambda, err = deriveRandomness(&fs, "lambda", &proof.Z)
		chZ <- err
		close(chZ)
	}()

	// evaluation of the blinded versions of l, r, o and bz
	// on the coset of the big domain
	var (
		blindedLBigXBitReversed []fr.Element
		blindedRBigXBitReversed []fr.Element
		blindedOBigXBitReversed []fr.Element
		blindedZBigXBitReversed []fr.Element
	)
	chEvalBL := make(chan struct{}, 1)
	chEvalBR := make(chan struct{}, 1)
	chEvalBO := make(chan struct{}, 1)
	go func() {
		blindedLBigXBitReversed = evaluateBigXBitReversed(blindedLCanonicalX, &pk.Domain[1])
		close(chEvalBL)
	}()
	go func() {
		blindedRBigXBitReversed = evaluateBigXBitReversed(blindedRCanonicalX, &pk.Domain[1])
		close(chEvalBR)
	}()
	go func() {
		blindedOBigXBitReversed = evaluateBigXBitReversed(blindedOCanonicalX, &pk.Domain[1])
		close(chEvalBO)
	}()

	var constraintsIndBigXBitReversed, orderingBigXBitReversed []fr.Element
	chConstraintInd := make(chan struct{}, 1)
	go func() {
		// compute qk in canonical basis, completed with the public inputs
		qkCompletedCanonical := make([]fr.Element, pk.Domain[0].Cardinality)
		copy(qkCompletedCanonical, fullWitness[:spr.NbPublicVariables])
		copy(qkCompletedCanonical[spr.NbPublicVariables:], pk.LQk[spr.NbPublicVariables:])
		pk.Domain[0].FFTInverse(qkCompletedCanonical, fft.DIF)
		fft.BitReverse(qkCompletedCanonical)

		// compute the evaluation of qlL+qrR+qmL.R+qoO+k on the coset of the big domain
		// → uses the blinded version of l, r, o
		<-chEvalBL
		<-chEvalBR
		<-chEvalBO
		constraintsIndBigXBitReversed = evaluateConstraintsBigXBitReversed(
			pk,
			blindedLBigXBitReversed,
			blindedRBigXBitReversed,
			blindedOBigXBitReversed,
			qkCompletedCanonical)
		close(chConstraintInd)
	}()

	chOrdering := make(chan error, 1)
	go func() {
		if err := <-chZ; err != nil {
			chOrdering <- err
			return
		}

		blindedZBigXBitReversed = evaluateBigXBitReversed(blindedZCanonicalX, &pk.Domain[1])
		// compute zmu*g1*g2*g3-z*f1*f2*f3 on the coset of the big domain
		// evalL, evalO, evalR are the evaluations of the blinded versions of l, r, o.
		<-chEvalBL
		<-chEvalBR
		<-chEvalBO
		orderingBigXBitReversed = evaluateOrderingDomainBigBitReversedOnX(
			pk,
			blindedZBigXBitReversed,
			blindedLBigXBitReversed,
			blindedRBigXBitReversed,
			blindedOBigXBitReversed,
			eta,
			gamma)
		chOrdering <- nil
		close(chOrdering)
	}()

	if err := <-chOrdering; err != nil {
		return nil, err
	}

	<-chConstraintInd

	// compute h in canonical form
	hx1, hx2, hx3 := computeQuotientCanonicalX(pk, constraintsIndBigXBitReversed, orderingBigXBitReversed, blindedZBigXBitReversed, lambda)

	// compute kzg commitments of hx1, hx2 and hx3
	if err := commitToQuotientX(hx1, hx2, hx3, proof, pk.Vk.KZGSRS); err != nil {
		return nil, err
	}

	// derive alpha
	alpha, err := deriveRandomness(&fs, "alpha", &proof.Hx[0], &proof.Hx[1], &proof.Hx[2])
	if err != nil {
		return nil, err
	}

	// open blinded Z at alpha*z
	var alphaShifted fr.Element
	alphaShifted.Mul(&alpha, &pk.Vk.Generator)
	var zShiftedAlpha []fr.Element
	proof.PartialZShiftedOpening, zShiftedAlpha, err = dkzg.Open(
		blindedZCanonicalX,
		alphaShifted,
		pk.Vk.KZGSRS,
	)
	if err != nil {
		return nil, err
	}

	// foldedHDigest = Comm(hx1) + αⁿ⁺²*Comm(hx2) + α²⁽ⁿ⁺²⁾*Comm(hx3)
	var bAlphaPowerNPlusTwo, bSize big.Int
	bSize.SetUint64(pk.Domain[0].Cardinality + 2) // +2 because of the masking (h of degree 3(n+2)-1)
	var alphaPowerNPlusTwo fr.Element
	alphaPowerNPlusTwo.Exp(alpha, &bSize)
	alphaPowerNPlusTwo.ToBigIntRegular(&bAlphaPowerNPlusTwo)
	foldedHxDigest := proof.Hx[2]
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerNPlusTwo)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[1])                          // αⁿ⁺²*Comm(h3)
	foldedHxDigest.ScalarMultiplication(&foldedHxDigest, &bAlphaPowerNPlusTwo) // α²⁽ⁿ⁺²⁾*Comm(h3) + αⁿ⁺²*Comm(h2)
	foldedHxDigest.Add(&foldedHxDigest, &proof.Hx[0])                          // α²⁽ⁿ⁺²⁾*Comm(h3) + αⁿ⁺²*Comm(h2) + Comm(h1)

	// foldedHx = h1 + α*h2 + α²*h3
	foldedHx := hx3
	utils.Parallelize(len(foldedHx), func(start, end int) {
		for i := start; i < end; i++ {
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerNPlusTwo) // αⁿ⁺²*h3
			foldedHx[i].Add(&foldedHx[i], &hx2[i])             // αⁿ⁺²*h3+h2
			foldedHx[i].Mul(&foldedHx[i], &alphaPowerNPlusTwo) // α²⁽ⁿ⁺²⁾*h3+αⁿ⁺²*h2
			foldedHx[i].Add(&foldedHx[i], &hx1[i])             // α²⁽ⁿ⁺²⁾*h3+αⁿ⁺²*h2 + h1
		}
	})

	// Batch open the first list of polynomials
	var evalsXOnAlpha [][]fr.Element
	proof.PartialBatchedProof, evalsXOnAlpha, err = dkzg.BatchOpenSinglePoint(
		[][]fr.Element{
			foldedHx,
			blindedLCanonicalX,
			blindedRCanonicalX,
			blindedOCanonicalX,
			pk.Ql,
			pk.Qr,
			pk.Qm,
			pk.Qo,
			pk.CQk,
			pk.S1Canonical,
			pk.S2Canonical,
			pk.S3Canonical,
			blindedZCanonicalX,
		},
		[]dkzg.Digest{
			foldedHxDigest,
			proof.LRO[0],
			proof.LRO[1],
			proof.LRO[2],
			pk.Vk.Ql,
			pk.Vk.Qr,
			pk.Vk.Qm,
			pk.Vk.Qo,
			pk.Vk.Qk,
			pk.Vk.S[0],
			pk.Vk.S[1],
			pk.Vk.S[2],
			proof.Z,
		},
		alpha,
		hFunc,
		pk.Vk.KZGSRS,
	)

	if mpi.SelfRank != 0 {
		log.Debug().Dur("took", time.Since(start)).Msg("prover done")
		if err != nil {
			return nil, err
		}

		return proof, nil
	}

	constraintSetSmallY := evalsXOnAlpha[1:9]
	chConstraintSetCanonicalY := make([]chan bool, 8)
	chConstraintSetBigY := make([]chan bool, 8)
	for i := range chConstraintSetCanonicalY {
		chConstraintSetCanonicalY[i] = make(chan bool, 1)
		chConstraintSetBigY[i] = make(chan bool, 1)
	}

	// evaluation of the versions of polynomials used in constraints
	// on the coset of the big domain in terms of Y
	constraintSetCanonicalY, constraintSetBigYBitReverse := computeCanonicalAndBigFromSmall(constraintSetSmallY,
		chConstraintSetCanonicalY,
		chConstraintSetBigY,
		globalDomain[0],
		globalDomain[1])

	var constraintsIndBigYBitReversed []fr.Element
	chConstraintInd = make(chan struct{}, 1)
	go func() {
		for i := range chConstraintSetBigY {
			<-chConstraintSetBigY[i]
		}

		constraintsIndBigYBitReversed = evaluateConstraintsDomainBigBitReversedOnY(
			constraintSetBigYBitReverse[0], // l
			constraintSetBigYBitReverse[1], // r
			constraintSetBigYBitReverse[2], // o
			constraintSetBigYBitReverse[3], // ql
			constraintSetBigYBitReverse[4], // qr
			constraintSetBigYBitReverse[5], // qm
			constraintSetBigYBitReverse[6], // qo
			constraintSetBigYBitReverse[7], // qk
		)
		close(chConstraintInd)
	}()

	orderingSetSmallY := append(evalsXOnAlpha[9:], zShiftedAlpha)
	chOrderingSetCanonicalY := make([]chan bool, 5)
	chOrderingSetBigY := make([]chan bool, 5)
	for i := range chOrderingSetCanonicalY {
		chOrderingSetCanonicalY[i] = make(chan bool, 1)
		chOrderingSetBigY[i] = make(chan bool, 1)
	}

	orderingSetCanonicalY, orderingSetBigYBitReverse := computeCanonicalAndBigFromSmall(orderingSetSmallY,
		chOrderingSetCanonicalY,
		chOrderingSetBigY,
		globalDomain[0],
		globalDomain[1])

	var orderingBigYBitReverse []fr.Element
	chOrdering = make(chan error, 1)
	go func() {
		for i := 0; i < 3; i++ {
			<-chConstraintSetBigY[i]
		}
		for i := range chOrderingSetBigY {
			<-chOrderingSetBigY[i]
		}

		if err := <-chZ; err != nil {
			chOrdering <- err
			return
		}

		// compute zmu*g1*g2*g3-z*f1*f2*f3 on the coset of the big domain
		// evalL, evalO, evalR are the evaluations of the blinded versions of l, r, o.
		orderingBigYBitReverse = evaluateOrderingDomainBigBitReversedOnY(
			pk,
			constraintSetBigYBitReverse[0], // l
			constraintSetBigYBitReverse[1], // r
			constraintSetBigYBitReverse[2], // o
			orderingSetBigYBitReverse[0],   // s1
			orderingSetBigYBitReverse[1],   // s2
			orderingSetBigYBitReverse[2],   // s3
			orderingSetBigYBitReverse[3],   // z
			orderingSetBigYBitReverse[4],   // zmu
			eta,
			gamma)
		chOrdering <- nil
		close(chOrdering)
	}()

	if err := <-chOrdering; err != nil {
		return nil, err
	}

	<-chConstraintInd

	chHxCanonicalY := make(chan bool, 5)
	chHxBigY := make(chan bool, 5)
	hxSetCanonicalY, hxSetBigYBitReversed := computeCanonicalAndBigFromSmall([][]fr.Element{evalsXOnAlpha[0]},
		[]chan bool{chHxCanonicalY},
		[]chan bool{chHxBigY},
		globalDomain[0],
		globalDomain[1])
	hxCanonicalY, hxBigYBitReversed := hxSetCanonicalY[0], hxSetBigYBitReversed[0]

	hyCanonical1, hyCanonical2, hyCanonical3 := computeQuotientCanonicalOnY(pk,
		constraintsIndBigYBitReversed,
		orderingBigYBitReverse,
		orderingSetBigYBitReverse[3], // z
		hxBigYBitReversed,
		lambda,
		alpha)

	// compute kzg commitments of hyCanonical1, hyCanonical2 and hyCanonical3
	if err := commitToQuotientOnY(hyCanonical1, hyCanonical2, hyCanonical3, proof, globalSRS); err != nil {
		return nil, err
	}

	// derive beta
	beta, err := deriveRandomness(&fs, "beta", &proof.Hy[0], &proof.Hy[1], &proof.Hy[2])
	if err != nil {
		return nil, err
	}

	var openingCanonicalY [][]fr.Element
	openingCanonicalY = append(openingCanonicalY, constraintSetCanonicalY...)
	openingCanonicalY = append(openingCanonicalY, orderingSetCanonicalY...)

	evalsOnBeta := evalPolynomialsAtPoint(openingCanonicalY, beta)

	// foldedHy = hy1 + β*hy2 + β²*hy3
	var bBetaPowerM big.Int
	bSize.SetUint64(globalDomain[0].Cardinality)
	var betaPowerM fr.Element
	betaPowerM.Exp(alpha, &bSize)
	betaPowerM.ToBigIntRegular(&bBetaPowerM)
	foldedHyDigest := proof.Hy[2]
	foldedHyDigest.ScalarMultiplication(&foldedHyDigest, &bBetaPowerM)
	foldedHyDigest.Add(&foldedHxDigest, &proof.Hy[1])
	foldedHyDigest.ScalarMultiplication(&foldedHxDigest, &bBetaPowerM)
	foldedHyDigest.Add(&foldedHxDigest, &proof.Hy[0])
	foldedHy := hyCanonical3
	utils.Parallelize(len(foldedHy), func(start, end int) {
		for i := start; i < end; i++ {
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)      // βᵐ*hy3
			foldedHy[i].Add(&foldedHy[i], &hyCanonical2[i]) // βᵐ*hy3+hy2
			foldedHy[i].Mul(&foldedHy[i], &betaPowerM)      // β²ᵐ*hy3+βᵐ*hy2
			foldedHy[i].Add(&foldedHy[i], &hyCanonical1[i]) // β²ᵐ*hy3+βᵐ*hy2 + hy1
		}
	})

	var (
		linearizedIdentitiesCanonicalY []fr.Element
		linearizedIdentitiesDigest     curve.G1Affine
		errLPoly                       error
	)
	chLpoly := make(chan struct{}, 1)

	go func() {
		linearizedIdentitiesCanonicalY = computeLinearizedIdentities(
			pk,
			evalsOnBeta[0],  // l
			evalsOnBeta[1],  // r
			evalsOnBeta[2],  // o
			evalsOnBeta[3],  // ql
			evalsOnBeta[4],  // qr
			evalsOnBeta[5],  // qo
			evalsOnBeta[6],  // qm
			evalsOnBeta[7],  // qk
			evalsOnBeta[8],  // s1
			evalsOnBeta[9],  // s2
			evalsOnBeta[10], // s3
			evalsOnBeta[11], // z
			evalsOnBeta[12], // zmu
			lambda,
			eta,
			gamma,
			alpha,
			beta,
			hxCanonicalY,
			foldedHy,
		)

		linearizedIdentitiesDigest, errLPoly = kzg.Commit(linearizedIdentitiesCanonicalY, globalSRS)
		close(chLpoly)
	}()

	<-chLpoly
	if errLPoly != nil {
		return nil, errLPoly
	}

	openingCanonicalY = append(openingCanonicalY, foldedHy, linearizedIdentitiesCanonicalY)

	var digestsY []curve.G1Affine
	digestsY = append(digestsY, proof.PartialBatchedProof.ClaimedDigests[1:]...) // no hx
	digestsY = append(digestsY, proof.PartialZShiftedOpening.ClaimedDigest, foldedHyDigest, linearizedIdentitiesDigest)

	proof.BatchedProof, err = kzg.BatchOpenSinglePoint(
		openingCanonicalY,
		digestsY,
		beta,
		hFunc,
		globalSRS,
	)

	if err != nil {
		return nil, err
	}

	return proof, nil
}

// eval evaluates c at p
func eval(c []fr.Element, p fr.Element) fr.Element {
	var r fr.Element
	for i := len(c) - 1; i >= 0; i-- {
		r.Mul(&r, &p).Add(&r, &c[i])
	}
	return r
}

func evalPolynomialsAtPoint(polys [][]fr.Element, point fr.Element) []fr.Element {
	var wg sync.WaitGroup
	wg.Add(len(polys))

	res := make([]fr.Element, len(polys))
	for i := range polys {
		go func(index int) {
			res[index] = eval(polys[index], point)
			wg.Done()
		}(i)
	}
	wg.Wait()
	return res
}

// fills proof.LRO with kzg commits of bcl, bcr and bco
func commitToLRO(bcl, bcr, bco []fr.Element, proof *Proof, srs *dkzg.SRS) error {
	n := runtime.NumCPU() / 2
	var err0, err1, err2 error
	chCommit0 := make(chan struct{}, 1)
	chCommit1 := make(chan struct{}, 1)
	go func() {
		proof.LRO[0], err0 = dkzg.Commit(bcl, srs, n)
		close(chCommit0)
	}()
	go func() {
		proof.LRO[1], err1 = dkzg.Commit(bcr, srs, n)
		close(chCommit1)
	}()
	if proof.LRO[2], err2 = dkzg.Commit(bco, srs, n); err2 != nil {
		return err2
	}
	<-chCommit0
	<-chCommit1

	if err0 != nil {
		return err0
	}

	return err1
}

func commitToQuotientX(h1, h2, h3 []fr.Element, proof *Proof, srs *dkzg.SRS) error {
	n := runtime.NumCPU() / 2
	var err0, err1, err2 error
	chCommit0 := make(chan struct{}, 1)
	chCommit1 := make(chan struct{}, 1)
	go func() {
		proof.Hx[0], err0 = dkzg.Commit(h1, srs, n)
		close(chCommit0)
	}()
	go func() {
		proof.Hx[1], err1 = dkzg.Commit(h2, srs, n)
		close(chCommit1)
	}()
	if proof.Hx[2], err2 = dkzg.Commit(h3, srs, n); err2 != nil {
		return err2
	}
	<-chCommit0
	<-chCommit1

	if err0 != nil {
		return err0
	}

	return err1
}

func commitToQuotientOnY(h1, h2, h3 []fr.Element, proof *Proof, srs *kzg.SRS) error {
	n := runtime.NumCPU() / 2
	var err0, err1, err2 error
	chCommit0 := make(chan struct{}, 1)
	chCommit1 := make(chan struct{}, 1)
	go func() {
		proof.Hy[0], err0 = kzg.Commit(h1, srs, n)
		close(chCommit0)
	}()
	go func() {
		proof.Hy[1], err1 = kzg.Commit(h2, srs, n)
		close(chCommit1)
	}()
	if proof.Hy[2], err2 = kzg.Commit(h3, srs, n); err2 != nil {
		return err2
	}
	<-chCommit0
	<-chCommit1

	if err0 != nil {
		return err0
	}

	return err1
}

// computeBlindedLROCanonicalX l, r, o in canonical basis with blinding
func computeBlindedLROCanonicalX(ll, lr, lo []fr.Element, domain *fft.Domain) (bcl, bcr, bco []fr.Element, err error) {
	// note that bcl, bcr and bco reuses cl, cr and co memory
	cl := make([]fr.Element, domain.Cardinality, domain.Cardinality+2)
	cr := make([]fr.Element, domain.Cardinality, domain.Cardinality+2)
	co := make([]fr.Element, domain.Cardinality, domain.Cardinality+2)

	chDone := make(chan error, 2)

	go func() {
		var err error
		copy(cl, ll)
		domain.FFTInverse(cl, fft.DIF)
		fft.BitReverse(cl)
		bcl, err = blindPoly(cl, domain.Cardinality, 1)
		chDone <- err
	}()
	go func() {
		var err error
		copy(cr, lr)
		domain.FFTInverse(cr, fft.DIF)
		fft.BitReverse(cr)
		bcr, err = blindPoly(cr, domain.Cardinality, 1)
		chDone <- err
	}()
	copy(co, lo)
	domain.FFTInverse(co, fft.DIF)
	fft.BitReverse(co)
	if bco, err = blindPoly(co, domain.Cardinality, 1); err != nil {
		return
	}
	err = <-chDone
	if err != nil {
		return
	}
	err = <-chDone
	return
}

// blindPoly blinds a polynomial by adding a Q(X)*(X**degree-1), where deg Q = order.
//
// * cp polynomial in canonical form
// * rou root of unity, meaning the blinding factor is multiple of X**rou-1
// * bo blinding order,  it's the degree of Q, where the blinding is Q(X)*(X**degree-1)
//
// WARNING:
// pre condition degree(cp) ⩽ rou + bo
// pre condition cap(cp) ⩾ int(totalDegree + 1)
func blindPoly(cp []fr.Element, rou, bo uint64) ([]fr.Element, error) {

	// degree of the blinded polynomial is max(rou+order, cp.Degree)
	totalDegree := rou + bo

	// re-use cp
	res := cp[:totalDegree+1]

	// random polynomial
	blindingPoly := make([]fr.Element, bo+1)
	for i := uint64(0); i < bo+1; i++ {
		if _, err := blindingPoly[i].SetRandom(); err != nil {
			return nil, err
		}
	}

	// blinding
	for i := uint64(0); i < bo+1; i++ {
		res[i].Sub(&res[i], &blindingPoly[i])
		res[rou+i].Add(&res[rou+i], &blindingPoly[i])
	}

	return res, nil

}

// evaluateLROSmallDomainX extracts the solution l, r, o, and returns it in lagrange form.
// solution = [ public | secret | internal ]
func evaluateLROSmallDomainX(spr *cs.SparseR1CS, pk *ProvingKey, solution []fr.Element) ([]fr.Element, []fr.Element, []fr.Element) {

	s := int(pk.Domain[0].Cardinality)

	var l, r, o []fr.Element
	l = make([]fr.Element, s)
	r = make([]fr.Element, s)
	o = make([]fr.Element, s)
	s0 := solution[0]

	for i := 0; i < spr.NbPublicVariables; i++ { // placeholders
		l[i] = solution[i]
		r[i] = s0
		o[i] = s0
	}
	offset := spr.NbPublicVariables
	for i := 0; i < len(spr.Constraints); i++ { // constraints
		l[offset+i] = solution[spr.Constraints[i].L.WireID()]
		r[offset+i] = solution[spr.Constraints[i].R.WireID()]
		o[offset+i] = solution[spr.Constraints[i].O.WireID()]
	}
	offset += len(spr.Constraints)

	for i := 0; i < s-offset; i++ { // offset to reach 2**n constraints (where the id of l,r,o is 0, so we assign solution[0])
		l[offset+i] = s0
		r[offset+i] = s0
		o[offset+i] = s0
	}

	return l, r, o

}

// computeZ computes Z, in canonical basis, where:
//
// * Z of degree n (domainNum.Cardinality)
// * Z(1)=1
// 								   (l(g^k)+η*g^k+γ)*(r(g^k)+uη*g^k+γ)*(o(g^k)+u²η*g^k+γ)
// * for i>0: Z(gⁱ) = Π_{k<i} -------------------------------------------------------
//								     (l(g^k)+η*s1(g^k)+γ)*(r(g^k)+η*s2(g^k)+γ)*(o(g^k)+η*s3(g^k)+γ)
//
//	* l, r, o are the solution in Lagrange basis, evaluated on the small domain
func computeBlindedZCanonicalX(l, r, o []fr.Element, pk *ProvingKey, beta, gamma fr.Element) ([]fr.Element, error) {

	// note that z has more capacity has its memory is reused for blinded z later on
	z := make([]fr.Element, pk.Domain[0].Cardinality, pk.Domain[0].Cardinality+3)
	nbElmts := int(pk.Domain[0].Cardinality)
	gInv := make([]fr.Element, pk.Domain[0].Cardinality)

	z[0].SetOne()
	gInv[0].SetOne()

	evaluationIDSmallDomain := getIDSmallDomain(&pk.Domain[0])

	utils.Parallelize(nbElmts-1, func(start, end int) {

		var f [3]fr.Element
		var g [3]fr.Element

		for i := start; i < end; i++ {

			f[0].Mul(&evaluationIDSmallDomain[i], &beta).Add(&f[0], &l[i]).Add(&f[0], &gamma)           //lᵢ+g^i*η+γ
			f[1].Mul(&evaluationIDSmallDomain[i+nbElmts], &beta).Add(&f[1], &r[i]).Add(&f[1], &gamma)   //rᵢ+u*g^i*η+γ
			f[2].Mul(&evaluationIDSmallDomain[i+2*nbElmts], &beta).Add(&f[2], &o[i]).Add(&f[2], &gamma) //oᵢ+u²*g^i*η+γ

			g[0].Mul(&evaluationIDSmallDomain[pk.Permutation[i]], &beta).Add(&g[0], &l[i]).Add(&g[0], &gamma)           //lᵢ+s₁(g^i)*η+γ
			g[1].Mul(&evaluationIDSmallDomain[pk.Permutation[i+nbElmts]], &beta).Add(&g[1], &r[i]).Add(&g[1], &gamma)   //rᵢ+s₂(g^i)*η+γ
			g[2].Mul(&evaluationIDSmallDomain[pk.Permutation[i+2*nbElmts]], &beta).Add(&g[2], &o[i]).Add(&g[2], &gamma) //oᵢ+s₃(g^i)*η+γ

			f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2]) // (lᵢ+g^i*η+γ)*(rᵢ+u*g^i*η+γ)*(oᵢ+u²*g^i*η+γ)
			g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2]) //  (lᵢ+s₁(g^i)*η+γ)*(rᵢ+s₂(g^i)*η+γ)*(oᵢ+s₃(g^i)*η+γ)

			gInv[i+1] = g[0]
			z[i+1] = f[0]
		}
	})

	gInv = fr.BatchInvert(gInv)
	for i := 1; i < nbElmts; i++ {
		z[i].Mul(&z[i], &z[i-1]).
			Mul(&z[i], &gInv[i])
	}

	pk.Domain[0].FFTInverse(z, fft.DIF)
	fft.BitReverse(z)

	return blindPoly(z, pk.Domain[0].Cardinality, 2)

}

// evaluateConstraintsBigXBitReversed computes the evaluation of lL+qrR+qqmL.R+qoO+k on
// the big domain coset.
//
// * evalL, evalR, evalO are the evaluation of the blinded solution vectors on odd cosets
// * qk is the completed version of qk, in canonical version
func evaluateConstraintsBigXBitReversed(pk *ProvingKey, evalL, evalR, evalO, qk []fr.Element) []fr.Element {
	var evalQl, evalQr, evalQm, evalQo, evalQk []fr.Element
	var wg sync.WaitGroup
	wg.Add(4)

	go func() {
		evalQl = evaluateBigXBitReversed(pk.Ql, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		evalQr = evaluateBigXBitReversed(pk.Qr, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		evalQm = evaluateBigXBitReversed(pk.Qm, &pk.Domain[1])
		wg.Done()
	}()
	go func() {
		evalQo = evaluateBigXBitReversed(pk.Qo, &pk.Domain[1])
		wg.Done()
	}()
	evalQk = evaluateBigXBitReversed(qk, &pk.Domain[1])
	wg.Wait()

	// computes the evaluation of qrR+qlL+qmL.R+qoO+k on the coset of the big domain
	utils.Parallelize(len(evalQk), func(start, end int) {
		var t0, t1 fr.Element
		for i := start; i < end; i++ {
			t1.Mul(&evalQm[i], &evalR[i]) // qm.r
			t1.Add(&t1, &evalQl[i])       // qm.r + ql
			t1.Mul(&t1, &evalL[i])        //  qm.l.r + ql.l

			t0.Mul(&evalQr[i], &evalR[i])
			t0.Add(&t0, &t1) // qm.l.r + ql.l + qr.r

			t1.Mul(&evalQo[i], &evalO[i])
			t0.Add(&t0, &t1)               // ql.l + qr.r + qm.l.r + qo.o
			evalQk[i].Add(&t0, &evalQk[i]) // ql.l + qr.r + qm.l.r + qo.o + k
		}
	})

	return evalQk
}

// evaluateConstraintsDomainBigBitReversedOnY computes the evaluation of lL+qrR+qqmL.R+qoO+k on
// the big domain coset.
//
// * evalL, evalR, evalO are the evaluation of the blinded solution vectors after partially opened on alpha
// on odd cosets
// * qk is the completed version of qk, in canonical version
func evaluateConstraintsDomainBigBitReversedOnY(evalL, evalR, evalO, evalQl, evalQr, evalQm, evalQo, evalQk []fr.Element) []fr.Element {
	// computes the evaluation of qrR+qlL+qmL.R+qoO+k on the coset of the big domain
	utils.Parallelize(len(evalQk), func(start, end int) {
		var t0, t1 fr.Element
		for i := start; i < end; i++ {
			t1.Mul(&evalQm[i], &evalR[i]) // qm.r
			t1.Add(&t1, &evalQl[i])       // qm.r + ql
			t1.Mul(&t1, &evalL[i])        //  qm.l.r + ql.l

			t0.Mul(&evalQr[i], &evalR[i])
			t0.Add(&t0, &t1) // qm.l.r + ql.l + qr.r

			t1.Mul(&evalQo[i], &evalO[i])
			t0.Add(&t0, &t1)               // ql.l + qr.r + qm.l.r + qo.o
			evalQk[i].Add(&t0, &evalQk[i]) // ql.l + qr.r + qm.l.r + qo.o + k
		}
	})

	return evalQk
}

// evaluateOrderingDomainBigBitReversedOnX computes the evaluation of Z(uX)g1g2g3-Z(X)f1f2f3 on the odd
// cosets of the big domain.
//
// * z evaluation of the blinded permutation accumulator polynomial on odd cosets
// * l, r, o evaluation of the blinded solution vectors on odd cosets
// * gamma randomization
func evaluateOrderingDomainBigBitReversedOnX(pk *ProvingKey, z, l, r, o []fr.Element, eta, gamma fr.Element) []fr.Element {

	nbElmts := int(pk.Domain[1].Cardinality)

	// computes  z_(μX)*(l(X)+s₁(X)*η+γ)*(r(X))+s₂(gⁱ)*η+γ)*(o(X))+s₃(X)*η+γ) - z(X)*(l(X)+X*η+γ)*(r(X)+u*X*η+γ)*(o(X)+u²*X*η+γ)
	// on the big domain (coset).
	res := make([]fr.Element, pk.Domain[1].Cardinality)

	nn := uint64(64 - bits.TrailingZeros64(uint64(nbElmts)))

	// needed to shift evalZ
	toShift := int(pk.Domain[1].Cardinality / pk.Domain[0].Cardinality)

	var cosetShift, cosetShiftSquare fr.Element
	cosetShift.Set(&pk.Vk.CosetShift)
	cosetShiftSquare.Square(&pk.Vk.CosetShift)

	utils.Parallelize(int(pk.Domain[1].Cardinality), func(start, end int) {

		var evaluationIDBigDomain fr.Element
		evaluationIDBigDomain.Exp(pk.Domain[1].Generator, big.NewInt(int64(start))).
			Mul(&evaluationIDBigDomain, &pk.Domain[1].FrMultiplicativeGen)

		var f [3]fr.Element
		var g [3]fr.Element

		for i := start; i < end; i++ {

			_i := bits.Reverse64(uint64(i)) >> nn
			_is := bits.Reverse64(uint64((i+toShift)%nbElmts)) >> nn

			// in what follows gⁱ is understood as the generator of the chosen coset of domainBig
			f[0].Mul(&evaluationIDBigDomain, &eta).Add(&f[0], &l[_i]).Add(&f[0], &gamma)                               //l(gⁱ)+gⁱ*η+γ
			f[1].Mul(&evaluationIDBigDomain, &cosetShift).Mul(&f[1], &eta).Add(&f[1], &r[_i]).Add(&f[1], &gamma)       //r(gⁱ)+u*gⁱ*η+γ
			f[2].Mul(&evaluationIDBigDomain, &cosetShiftSquare).Mul(&f[2], &eta).Add(&f[2], &o[_i]).Add(&f[2], &gamma) //o(gⁱ)+u²*gⁱ*η+γ

			g[0].Mul(&pk.EvaluationPermutationBigDomainBitReversed[_i], &eta).Add(&g[0], &l[_i]).Add(&g[0], &gamma)                //l(gⁱ))+s1(gⁱ)*η+γ
			g[1].Mul(&pk.EvaluationPermutationBigDomainBitReversed[int(_i)+nbElmts], &eta).Add(&g[1], &r[_i]).Add(&g[1], &gamma)   //r(gⁱ))+s2(gⁱ)*η+γ
			g[2].Mul(&pk.EvaluationPermutationBigDomainBitReversed[int(_i)+2*nbElmts], &eta).Add(&g[2], &o[_i]).Add(&g[2], &gamma) //o(gⁱ))+s3(gⁱ)*η+γ

			f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2]).Mul(&f[0], &z[_i])  // z(gⁱ)*(l(gⁱ)+g^i*η+γ)*(r(g^i)+u*g^i*η+γ)*(o(g^i)+u²*g^i*η+γ)
			g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2]).Mul(&g[0], &z[_is]) //  z_(μgⁱ)*(l(gⁱ))+s₁(gⁱ)*η+γ)*(r(gⁱ))+s₂(gⁱ)*η+γ)*(o(gⁱ))+s₃(gⁱ)*η+γ)

			res[_i].Sub(&g[0], &f[0]) // z_(μgⁱ)*(l(gⁱ))+s₁(gⁱ)*η+γ)*(r(gⁱ))+s₂(gⁱ)*η+γ)*(o(gⁱ))+s₃(gⁱ)*η+γ) - z(gⁱ)*(l(gⁱ)+g^i*η+γ)*(r(g^i)+u*g^i*η+γ)*(o(g^i)+u²*g^i*η+γ)

			evaluationIDBigDomain.Mul(&evaluationIDBigDomain, &pk.Domain[1].Generator) // gⁱ*g
		}
	})

	return res
}

// evaluateOrderingDomainBigBitReversedOnY computes the evaluation of Z(Y, uα)g1g2g3-Z(Y, α)f1f2f3 on the odd
// cosets of the big domain.
//
// * l, r, o s1, s2, s3, z, zmu partially opened on alpha and then evaluated on large cosets in bit reversed order
// * eta, gamma randomization
func evaluateOrderingDomainBigBitReversedOnY(pk *ProvingKey, l, r, o, s1, s2, s3, z, zmu []fr.Element, eta, gamma fr.Element) []fr.Element {
	// computes  z_(Y, μα)*(l(Y, α)+s₁(Y, α)*η+γ)*(r(Y, α))+s₂(Y, α)*η+γ)*(o(Y, α))+s₃(Y, α)*η+γ) - z(Y, α)*(l(Y, α)+α*η+γ)*(r(Y, α)+u*α*η+γ)*(o(Y, α)+u²*α*η+γ)
	// on the big domain (coset).
	res := make([]fr.Element, globalDomain[0].Cardinality)

	var cosetShift, cosetShiftSquare fr.Element
	cosetShift.Set(&pk.Vk.CosetShift)
	cosetShiftSquare.Square(&pk.Vk.CosetShift)

	utils.Parallelize(int(globalDomain[1].Cardinality), func(start, end int) {

		var evaluationIDBigDomain fr.Element
		evaluationIDBigDomain.Exp(globalDomain[1].Generator, big.NewInt(int64(start))).
			Mul(&evaluationIDBigDomain, &globalDomain[1].FrMultiplicativeGen)

		var f [3]fr.Element
		var g [3]fr.Element

		for i := start; i < end; i++ {
			// in what follows gⁱ is understood as the generator of the chosen coset of domainBig
			f[0].Mul(&evaluationIDBigDomain, &eta).Add(&f[0], &l[i]).Add(&f[0], &gamma)                               //l(gⁱ, α)+α*η+γ
			f[1].Mul(&evaluationIDBigDomain, &cosetShift).Mul(&f[1], &eta).Add(&f[1], &r[i]).Add(&f[1], &gamma)       //r(gⁱ, α)+u*α*η+γ
			f[2].Mul(&evaluationIDBigDomain, &cosetShiftSquare).Mul(&f[2], &eta).Add(&f[2], &o[i]).Add(&f[2], &gamma) //o(gⁱ, α)+u²*α*η+γ

			g[0].Mul(&s1[i], &eta).Add(&g[0], &l[i]).Add(&g[0], &gamma) // l(gⁱ, α))+s1(gⁱ, α)*η+γ
			g[1].Mul(&s2[i], &eta).Add(&g[1], &r[i]).Add(&g[1], &gamma) // r(gⁱ, α))+s2(gⁱ, α)*η+γ
			g[2].Mul(&s3[i], &eta).Add(&g[2], &o[i]).Add(&g[2], &gamma) // o(gⁱ, α))+s3(gⁱ, α)*η+γ

			f[0].Mul(&f[0], &f[1]).Mul(&f[0], &f[2]).Mul(&f[0], &z[i])   // z(gⁱ, α)*(l(gⁱ, α)+α*η+γ)*(r(gⁱ, α)+u*α*η+γ)*(o(gⁱ, α)+u²*α*η+γ)
			g[0].Mul(&g[0], &g[1]).Mul(&g[0], &g[2]).Mul(&g[0], &zmu[i]) // z_(gⁱ, μα)*(l(gⁱ, α))+s₁(gⁱ, α)*η+γ)*(r(gⁱ, α))+s₂(gⁱ, α)*η+γ)*(o(gⁱ, α))+s₃(gⁱ, α)*η+γ)

			res[i].Sub(&g[0], &f[0]) // z_(gⁱ, μα)*(l(gⁱ, α))+s₁(gⁱ, α)*η+γ)*(r(gⁱ, α))+s₂(gⁱ, α)*η+γ)*(o(gⁱ, α))+s₃(gⁱ, α)*η+γ) - z(gⁱ, α)*(l(gⁱ, α)+α*η+γ)*(r(gⁱ, α)+u*α*η+γ)*(o(gⁱ, α)+u²*α*η+γ)

			evaluationIDBigDomain.Mul(&evaluationIDBigDomain, &globalDomain[1].Generator) // gⁱ*g
		}
	})

	return res
}

// evaluateBigXBitReversed evaluates poly (canonical form) of degree m<n where n=domainH.Cardinality
// on the big domain (coset).
//
// Puts the result in res of size n.
// Warning: result is in bit reversed order, we do a bit reverse operation only once in computeQuotientCanonical
func evaluateBigXBitReversed(poly []fr.Element, domainH *fft.Domain) []fr.Element {
	res := make([]fr.Element, domainH.Cardinality)
	copy(res, poly)
	domainH.FFT(res, fft.DIF, true)
	return res
}

func computeBigFromCanonical(polys [][]fr.Element, chBigEvalDone []chan bool, smallDomain *fft.Domain, bigDomain *fft.Domain) [][]fr.Element {
	bigEvals := make([][]fr.Element, bigDomain.Cardinality)
	for i := range polys {
		go func(index int, finished chan bool) {
			bigEvals[index] = evaluateBigXBitReversed(polys[index], bigDomain)
			finished <- true
		}(i, chBigEvalDone[i])
	}
	return bigEvals
}

// computeCanonicalAndBigFromSmall evaluates poly (lagrange on small domain form) on big domain
func computeCanonicalAndBigFromSmall(smallEvals [][]fr.Element, chPolysDone []chan bool, chEvalsDone []chan bool, smallDomain *fft.Domain, bigDomain *fft.Domain) ([][]fr.Element, [][]fr.Element) {
	num := len(smallEvals)
	polys := make([][]fr.Element, num)
	bigEvals := make([][]fr.Element, num)

	// create and spawn ten goroutines
	for i := range smallEvals {
		go func(index int, finished chan bool) {
			poly := make([]fr.Element, smallDomain.Cardinality)
			copy(poly, smallEvals[index])
			smallDomain.FFTInverse(poly, fft.DIF)
			fft.BitReverse(poly)
			polys[index] = poly
			close(finished)
		}(i, chPolysDone[i])

		go func(index int, finished chan bool) {
			<-chPolysDone[index]
			bigEvals[index] = evaluateBigXBitReversed(polys[index], bigDomain)
			close(finished)
		}(i, chEvalsDone[i])
	}

	return polys, bigEvals
}

// evaluateXnMinusOneDomainBigCoset evalutes Xᵐ-1 on DomainBig coset
func evaluateXnMinusOneDomainBigCoset(domainBig, domainSmall *fft.Domain) []fr.Element {

	ratio := domainBig.Cardinality / domainSmall.Cardinality

	res := make([]fr.Element, ratio)

	expo := big.NewInt(int64(domainSmall.Cardinality))
	res[0].Exp(domainBig.FrMultiplicativeGen, expo)

	var t fr.Element
	t.Exp(domainBig.Generator, big.NewInt(int64(domainSmall.Cardinality)))

	for i := 1; i < int(ratio); i++ {
		res[i].Mul(&res[i-1], &t)
	}

	var one fr.Element
	one.SetOne()
	for i := 0; i < int(ratio); i++ {
		res[i].Sub(&res[i], &one)
	}

	return res
}

// computeQuotientCanonicalX computes h in canonical form, split as h1+X^mh2+X²mh3 such that
//
// ql(X)L(X)+qr(X)R(X)+qm(X)L(X)R(X)+qo(X)O(X)+k(X) + λ.(z(μX)*g₁(X)*g₂(X)*g₃(X)-z(X)*f₁(X)*f₂(X)*f₃(X)) + λ²*L₁(X)*(Z(X)-1)= h(X)Z(X)
//
// constraintInd, constraintOrdering are evaluated on the big domain (coset).
func computeQuotientCanonicalX(pk *ProvingKey, evaluationConstraintsIndBitReversed, evaluationConstraintOrderingBitReversed, evaluationBlindedZDomainBigBitReversed []fr.Element, lambda fr.Element) ([]fr.Element, []fr.Element, []fr.Element) {

	h := make([]fr.Element, pk.Domain[1].Cardinality)

	// evaluate Z = Xᵐ-1 on a coset of the big domain
	evaluationXnMinusOneInverse := evaluateXnMinusOneDomainBigCoset(&pk.Domain[1], &pk.Domain[0])
	evaluationXnMinusOneInverse = fr.BatchInvert(evaluationXnMinusOneInverse)

	// computes L₁ (canonical form)
	startsAtOne := make([]fr.Element, pk.Domain[1].Cardinality)
	for i := 0; i < int(pk.Domain[0].Cardinality); i++ {
		startsAtOne[i].Set(&pk.Domain[0].CardinalityInv)
	}
	pk.Domain[1].FFT(startsAtOne, fft.DIF, true)

	// ql(X)L(X)+qr(X)R(X)+qm(X)L(X)R(X)+qo(X)O(X)+k(X) + λ.(z(μX)*g₁(X)*g₂(X)*g₃(X)-z(X)*f₁(X)*f₂(X)*f₃(X)) + λ**2*L₁(X)(Z(X)-1)
	// on a coset of the big domain
	nn := uint64(64 - bits.TrailingZeros64(pk.Domain[1].Cardinality))

	var one fr.Element
	one.SetOne()

	ratio := pk.Domain[1].Cardinality / pk.Domain[0].Cardinality

	utils.Parallelize(int(pk.Domain[1].Cardinality), func(start, end int) {
		var t fr.Element
		for i := uint64(start); i < uint64(end); i++ {

			_i := bits.Reverse64(i) >> nn

			t.Sub(&evaluationBlindedZDomainBigBitReversed[_i], &one) // evaluates L₁(X)*(Z(X)-1) on a coset of the big domain
			h[_i].Mul(&startsAtOne[_i], &lambda).Mul(&h[_i], &t).
				Add(&h[_i], &evaluationConstraintOrderingBitReversed[_i]).
				Mul(&h[_i], &lambda).
				Add(&h[_i], &evaluationConstraintsIndBitReversed[_i]).
				Mul(&h[_i], &evaluationXnMinusOneInverse[i%ratio])
		}
	})

	// put h in canonical form. h is of degree 3*(n+1)+2.
	// using fft.DIT put h revert bit reverse
	pk.Domain[1].FFTInverse(h, fft.DIT, true)

	// degree of hi is n+2 because of the blinding
	h1 := h[:pk.Domain[0].Cardinality+2]
	h2 := h[pk.Domain[0].Cardinality+2 : 2*(pk.Domain[0].Cardinality+2)]
	h3 := h[2*(pk.Domain[0].Cardinality+2) : 3*(pk.Domain[0].Cardinality+2)]

	return h1, h2, h3

}

// computeQuotientCanonicalOnY computes h in canonical form, split as h1+Y^mh2+Y²mh3 such that
//
// ql(Y, α)L(Y, α)+qr(Y, α)R(Y, α)+qm(Y, α)L(Y, α)R(Y, α)+qo(Y, α)O(Y, α)+k(Y, α) + λ.(z(Y, μα)*g₁(Y, α)*g₂(Y, α)*g₃(Y, α)-z(Y, α)*f₁(Y, α)*f₂(Y, α)*f₃(Y, α)) + λ²*L₁(α)*(Z(Y, α)-1) - hx(Y, α)Z(X) = hy(Y)Z(Y)
//
// constraintInd, constraintOrdering are evaluated on the big domain (coset).
func computeQuotientCanonicalOnY(pk *ProvingKey, evaluationConstraintsIndBitReversed, evaluationConstraintOrderingBitReversed, evaluationZDomainBigBitReversed, evaluationHxBitReversed []fr.Element, lambda, alpha fr.Element) ([]fr.Element, []fr.Element, []fr.Element) {
	h := make([]fr.Element, globalDomain[1].Cardinality)

	// evaluate Z = Xᵐ-1 on a coset of the big domain
	evaluationXmMinusOneInverse := evaluateXnMinusOneDomainBigCoset(globalDomain[1], globalDomain[0])
	evaluationXmMinusOneInverse = fr.BatchInvert(evaluationXmMinusOneInverse)

	nn := uint64(64 - bits.TrailingZeros64(globalDomain[1].Cardinality))
	var one fr.Element
	one.SetOne()

	var lagrangeAlpha, den, frNbElmt fr.Element
	nbElmt := int64(globalDomain[0].Cardinality)
	lagrangeAlpha.Set(&alpha).
		Exp(lagrangeAlpha, big.NewInt(nbElmt)).
		Sub(&lagrangeAlpha, &one)
	frNbElmt.SetUint64(uint64(nbElmt))
	den.Sub(&alpha, &one).
		Inverse(&den)
	lagrangeAlpha.Mul(&lagrangeAlpha, &den). // L₁ = (αⁿ⁻¹)/(α-1)
							Mul(&lagrangeAlpha, &lambda).
							Mul(&lagrangeAlpha, &lambda).
							Mul(&lagrangeAlpha, &pk.Domain[0].CardinalityInv) // (1/n)*λ²*L₁(α)

	ratio := globalDomain[1].Cardinality / globalDomain[0].Cardinality

	utils.Parallelize(int(globalDomain[1].Cardinality), func(start, end int) {
		var t fr.Element
		for i := uint64(start); i < uint64(end); i++ {

			_i := bits.Reverse64(i) >> nn

			t.Sub(&evaluationZDomainBigBitReversed[_i], &one).Mul(&t, &lagrangeAlpha) // evaluates λ²*L₁(X)*(Z(X)-1) on a coset of the big domain
			h[_i].Mul(&evaluationConstraintOrderingBitReversed[_i], &lambda).
				Add(&h[_i], &evaluationConstraintsIndBitReversed[_i]).
				Mul(&h[_i], &evaluationXmMinusOneInverse[i%ratio]).
				Add(&h[_i], &t)
		}
	})

	// put h in canonical form. h is of degree 3*(n+1)+2.
	// using fft.DIT put h revert bit reverse
	pk.Domain[1].FFTInverse(h, fft.DIT, true)

	// degree of hi is n+2 because of the blinding
	h1 := h[:pk.Domain[0].Cardinality+2]
	h2 := h[pk.Domain[0].Cardinality+2 : 2*(pk.Domain[0].Cardinality+2)]
	h3 := h[2*(pk.Domain[0].Cardinality+2) : 3*(pk.Domain[0].Cardinality+2)]
	return h1, h2, h3
}

// computeLinearizedIdentities computes the linearized polynomial in canonical basis.
// The purpose is to commit and open all in one hx and hy.
// * l, r, o, ql, qr, qm, qo, qk are the evaluation of l, r, o, ql, qr, qm, qo, qk at alpha
// * s1, s2, s3, z, zmu are the evaluation of s1, s2, s3, z at alpha, z at mu*alpha
// * pk is the proving key: the linearized polynomial is a linear combination of hx and folded hy.
//
// The Linearized identities is:
//
// λ²*L₁(α)*(Z(β,α) - 1)
// + λ*( (l(α)+η*s1(α)+γ)*(r(α)+η*s2(α)+γ)*(o(α)+η*s3(α)+γ)*Z(β,μα)- (l(α)+η*id1(α)+γ)*(r(α)+η*id2(α)+γ)*(o(α)+η*id3(α)+γ)*Z(β,α) )
// + l(β,α)*Ql(β,α) + l(β,α)r(β,α)*Qm(β,α) + r(β,α)*Qr(β,α) + o(β,α)*Qo(β,α) + Qk(β,α)
// - Zn(α)*Hx(Y,α) - Zm(β)*(Hy1(Y) + β**m*Hy2(Y) + β**(2m)*Hy3(Y))
func computeLinearizedIdentities(pk *ProvingKey, l, r, o, ql, qr, qm, qo, qk, s1, s2, s3, z, zmu, lambda, eta, gamma, alpha, beta fr.Element, hxCanonicalY, foldedHy []fr.Element) []fr.Element {
	// first part: individual constraints
	var firstPart fr.Element
	ql.Mul(&ql, &l)
	qr.Mul(&qr, &r)
	qm.Mul(&qm, &l).Mul(&qm, &r)
	qo.Mul(&qo, &o)
	firstPart.Add(&ql, &qr).Add(&firstPart, &qm).Add(&firstPart, &qo).Add(&firstPart, &qk)

	// second part:
	// (l(α)+η*s1(α)+γ)*(r(α)+η*s2(α)+γ)*(o(α)+η*s3(α)+γ)*Z(β,μα)- (l(α)+η*id1(α)+γ)*(r(α)+η*id2(α)+γ)*(o(α)+η*id3(α)+γ)*Z(β,α)
	s1.Mul(&s1, &eta).Add(&s1, &l).Add(&s1, &gamma) // (l(α)+η*s1(α)+γ)
	s2.Mul(&s2, &eta).Add(&s2, &r).Add(&s2, &gamma) // (r(α)+η*s2(α)+γ)
	s3.Mul(&s3, &eta).Add(&s3, &o).Add(&s3, &gamma) // (o(α)+η*s3(α)+γ)
	s1.Mul(&s1, &s2).Mul(&s1, &s3).Mul(&s1, &zmu)   // (l(α)+η*s1(α)+γ)*(r(α)+η*s2(α)+γ)*(o(α)+η*s3(α)+γ)*Z(β,μα)

	var ualpha, uualpha fr.Element
	ualpha.Mul(&alpha, &pk.Vk.CosetShift)
	uualpha.Mul(&alpha, &pk.Vk.CosetShift)

	var secondPart, tmp fr.Element
	secondPart.Mul(&eta, &alpha).Add(&secondPart, &l).Add(&secondPart, &gamma) // (l(α)+η*α+γ)
	tmp.Mul(&eta, &ualpha).Add(&tmp, &r).Add(&tmp, &gamma)                     // (r(α)+η*u*α+γ)
	secondPart.Mul(&secondPart, &tmp)                                          // (l(α)+η*α+γ)*(r(α)+η*u*α+γ)
	tmp.Mul(&eta, &uualpha).Add(&tmp, &o).Add(&tmp, &gamma)                    // (o(α)+η*u²*α+γ)
	secondPart.Mul(&secondPart, &tmp).                                         // (l(α)+η*α+γ)*(r(α)+η*u*α+γ)*(o(α)+η*u²*α+γ)
											Mul(&secondPart, &z)
	secondPart.Sub(&s1, &secondPart) // -(l(α)+η*α+γ)*(r(α)+η*u*α+γ)*(o(α)+η*u²*α+γ)

	// third part L₁(α)*(Z(β,α)-1)
	var thirdPart, one, den, frNbElmt fr.Element
	one.SetOne()
	z.Sub(&z, &one)
	nbElmt := int64(pk.Domain[0].Cardinality)
	thirdPart.Set(&alpha).
		Exp(thirdPart, big.NewInt(nbElmt)).
		Sub(&thirdPart, &one)
	frNbElmt.SetUint64(uint64(nbElmt))
	den.Sub(&alpha, &one).
		Inverse(&den)
	thirdPart.Mul(&thirdPart, &den). // L₁ = (αⁿ⁻¹)/(α-1)
						Mul(&thirdPart, &pk.Domain[0].CardinalityInv). // (1/n)*λ²*L₁(α)
						Mul(&thirdPart, &z)

	linPol := make([]fr.Element, globalDomain[0].Cardinality)
	linPol[0].Mul(&thirdPart, &lambda).Add(&linPol[0], &secondPart).Mul(&linPol[0], &lambda).Add(&linPol[0], &firstPart)

	var vanishingX, vanishingY fr.Element
	vanishingX.Exp(alpha, big.NewInt(int64(pk.Domain[0].Cardinality)))
	vanishingX.Sub(&vanishingX, &one)
	vanishingY.Exp(beta, big.NewInt(int64(globalDomain[0].Cardinality)))
	vanishingY.Sub(&vanishingY, &one)

	utils.Parallelize(len(linPol), func(start, end int) {
		var t0, t1 fr.Element
		for i := start; i < end; i++ {
			t0.Mul(&hxCanonicalY[i], &vanishingX)
			linPol[i].Sub(&linPol[i], &t0)    // - Zn(α)*Hx(Y,α)
			t1.Mul(&foldedHy[i], &vanishingY) // - Zm(β)*(Hy1(Y) + β**m*Hy2(Y) + β**(2m)*Hy3(Y))
			linPol[i].Sub(&linPol[i], &t1)
		}
	})

	return linPol
}
